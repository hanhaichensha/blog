<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[翰海尘沙]]></title>
  <subtitle><![CDATA[进击的程序员]]></subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  <link href="http://hanhaichensha.coding.me/"/>
  <updated>2016-11-04T05:54:16.087Z</updated>
  <id>http://hanhaichensha.coding.me/</id>
  
  <author>
    <name><![CDATA[翰海尘沙]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[C++11特性与应用（三）]]></title>
    <link href="http://hanhaichensha.coding.me/2016/08/09/C-11%E7%89%B9%E6%80%A7%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://hanhaichensha.coding.me/2016/08/09/C-11特性与应用（三）/</id>
    <published>2016-08-09T09:33:54.000Z</published>
    <updated>2016-11-04T05:54:16.087Z</updated>
    <content type="html"><![CDATA[<h3 id="基于范围的for循环">基于范围的for循环</h3><p>基于范围的for循环非常的简洁，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : arr)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++98/03版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = arr.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; it != arr.end(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相比之下，C++版本更加简洁。</p>
<h4 id="基于范围的for循环使用细节">基于范围的for循环使用细节</h4><p>注意到基于范围的for循环中的auto n，推导出来的是int类型，也就是说<strong>auto推导出来的类型是容器的value_type，而不是迭代器</strong>。</p>
<p>看到for (auto n : arr)这句，有人会怀疑对容器的访问是没取一个值访问一次容器。事实真是这样吗？我们可以用下面的代码验证一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; get_range(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val : get_range())</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line">get_range</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>从上面的结果可以看出，for (auto val : get_range())对容器只访问了一次。说明<strong>基于范围的for循环，冒号后面的表达式只会被执行一次</strong></p>
<p>在遍历时，对容器进行修改的情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> val : arr)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">                arr.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"=================================="</span> &lt;&lt; <span class="built_in">std</span>::endl;<span class="keyword">for</span>(<span class="keyword">auto</span> val : arr)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">==================================</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>上面输出结果是在gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1)环境下的输出结果。对于同的编译器有不同的结果，随意在遍历容器时，尽量不要修改容器。而且可以看来上面的第一次变量虽然改变了容器，但是，遍历次数并没有增加。基于范围的for循环其实是普通for循环的语法糖，它等效下面的循环(参考ISO/IEC 14882 2014, 6.5.4 The range-based for statement)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> val : arr)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        arr.push_back(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面几句，等效于下面语句</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> &amp;&amp; __range = (arr);</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">auto</span> __begin = __range.begin(),__end = __range.end(); __begin != __end; ++__begin ) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> val = *__begin;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        arr.push_back(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的分析，我们知道只要一个容器实现了如下功能就能自定义一个容器，使得它也可以使用基于范围的for循环：</p>
<ol>
<li>容器要提供begin()和end()接口，返回一个该容器的迭代器；</li>
<li>容器的迭代器，实现重载前置++、解引用*和!=运算符；</li>
</ol>
<p>只要实现了上面两个要求，就可以将此自定义对象进行范围for循环了，下面实现一个针对整数的不完整实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> range_container</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> iterator</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> cursor_;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		iterator(<span class="keyword">int</span> cursor):cursor_(cursor)&#123;&#125;</span><br><span class="line">		<span class="keyword">int</span> <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> cursor_;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; rhs) <span class="keyword">const</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> cursor_ != rhs.cursor_;</span><br><span class="line">		&#125;</span><br><span class="line">		iterator&amp; <span class="keyword">operator</span>++(<span class="keyword">void</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			++cursor_;</span><br><span class="line">			<span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">class</span> container</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">using</span> const_iterator = <span class="keyword">const</span> range_container::iterator;</span><br><span class="line">		<span class="keyword">int</span> begin_;</span><br><span class="line">		<span class="keyword">int</span> end_;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		container(<span class="keyword">int</span> begin, <span class="keyword">int</span> end):begin_(begin),end_(end + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">const_iterator <span class="title">begin</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;begin_&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">const_iterator <span class="title">end</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;end_&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">&#125;<span class="comment">// range_container namespace end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        range_container::container c&#123; <span class="number">1</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> val : c)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="函数包装器和绑定器">函数包装器和绑定器</h3><h4 id="可调用对象">可调用对象</h4><p>在C++中有一下几种对象可以作为可调用对象，也就是可以进行函数调用：</p>
<ol>
<li>函数指针；</li>
<li>仿函数，具有operator()成员函数的类对象；</li>
<li>可以转换为函数指针的类对象，重载了类型转换符，并返回一个函数指针；</li>
<li>类成员函数指针；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Bar</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">fr_t</span> = <span class="keyword">void</span>(*)(<span class="keyword">void</span>);</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">fr_t</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> func;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mem_func</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> (*func_ptr)(<span class="keyword">void</span>) = &amp;func;		<span class="comment">//1、函数指针</span></span><br><span class="line">	func_ptr();</span><br><span class="line"></span><br><span class="line">	Foo foo;							<span class="comment">//2、仿函数</span></span><br><span class="line">	foo();</span><br><span class="line"></span><br><span class="line">	Bar bar;							<span class="comment">//3、可以转换为函数指针的类对象</span></span><br><span class="line">	bar();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (A::*mem_func_ptr)(<span class="keyword">void</span>) = &amp;A::mem_func;</span><br><span class="line">	A aa;</span><br><span class="line">	(aa.*mem_func_ptr)();				<span class="comment">//4、类成员函数指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可调用对象的类型称为<strong>可调用类型</strong>。</p>
<h4 id="std::function函数包装器">std::function函数包装器</h4><p>现在思考一问题，以上的可调用类型都可充当一个回调函数类型传递给一个接口，由于可调用类型这么多，我们必须的将接口进行多次重载。如果你知道可调用对象包装器，你就无需进行重载了。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a &amp; <span class="number">0x01</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Even</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a &amp; <span class="number">0x01</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Bar</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isEven_static</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a &amp; <span class="number">0x01</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> FuncTest</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; callback_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	FuncTest(<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; func):callback_(func)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(callback_(i))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">FuncTest <span class="title">ft1</span><span class="params">(isEven)</span></span>;					<span class="comment">//1、函数指针</span></span><br><span class="line">	ft1.output();</span><br><span class="line"></span><br><span class="line">	Even even;							<span class="comment">//2、仿函数</span></span><br><span class="line">	<span class="function">FuncTest <span class="title">ft2</span><span class="params">(even)</span></span>;</span><br><span class="line">	ft2.output();</span><br><span class="line"></span><br><span class="line">	<span class="function">FuncTest <span class="title">ft3</span><span class="params">(Bar::isEven_static)</span></span>;		<span class="comment">//3、静态成员函数指针</span></span><br><span class="line">	ft3.output();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">==========================</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">==========================</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>从上面的例子中可以看到，std::function函数包装器可以接收如下可调用对象：</p>
<ol>
<li>函数指针；</li>
<li>仿函数；</li>
<li>可以转换为函数指针的类对象，更准确应该是静态成员函数指针。</li>
</ol>
<p>可以看到，std::function函数包装器不能容纳<strong>类成员函数指针</strong>，会报下面错误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Bar</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a &amp; <span class="number">0x01</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> (Bar::*func_ptr)(<span class="keyword">int</span>) = &amp;Bar::isEven;</span><br><span class="line">	Bar bar;			</span><br><span class="line">	<span class="function">FuncTest <span class="title">ft1</span><span class="params">(bar.*func_ptr)</span></span>;				<span class="comment">//4、类成员函数指针</span></span><br><span class="line">	ft1.output();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line">error: invalid use of non-<span class="function"><span class="keyword">static</span> member function</span><br><span class="line">  FuncTest <span class="title">ft1</span><span class="params">(bar.*func_ptr)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>也就是说只有是类成员是静态函数指针才能被std::function函数包装器容纳。其实在可以转换为函数指针的类对象中，重载类型转换符，返回的就是一个静态成员函数的指针。</p>
<h4 id="std::bind绑定器">std::bind绑定器</h4><p>不知道大家有没有写过类似如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_1</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	output_1(a);</span><br><span class="line">	output_2(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_3</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	output_2(<span class="number">100</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_4</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	output_2(a, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总觉的上面的代码有点别扭，如果output_3和output_4中的常数多出一种情况50，又得添加两个函数接口，十分麻烦。这时如果你使用std::bind绑定器，将可调用对象和它的函数进行绑定，那么将会很方便，你只需要定义output_1和output_2两个接口，让接口调用这使用std::bind创建出他们希望的固定参数值的output了。如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// API </span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_1</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	output_1(a);</span><br><span class="line">	output_2(b);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// Caller</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> output_3 = <span class="built_in">std</span>::bind(output_2,<span class="number">100</span>,<span class="built_in">std</span>::placeholders::_1);		<span class="comment">//即效果如output_2(100,a);</span></span><br><span class="line">	<span class="keyword">auto</span> output_4 = <span class="built_in">std</span>::bind(output_2,<span class="built_in">std</span>::placeholders::_1,<span class="number">100</span>);		<span class="comment">//即效果如output_2(a,100);</span></span><br><span class="line">	output_3(<span class="number">3</span>);		<span class="comment">//相当于调用output_2(100,3)效果</span></span><br><span class="line">	output_4(<span class="number">4</span>);		<span class="comment">//相当于调用output_2(4,100)效果</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="number">100</span>		<span class="number">3</span></span><br><span class="line"><span class="number">4</span>		<span class="number">100</span></span><br></pre></td></tr></table></figure></p>
<p>std::bind用法说明：</p>
<ol>
<li>参数一，要绑定的函数（如上output_2）;</li>
<li>参数二，传给绑定函数的第一个参数（如上，100传给output_2，即output_2(100,x)，x表示未知参数），参数三，传给绑定函数的第二个参数，以此类推；</li>
<li>如果参数是std::placeholders，std::placeholders::_1表示将调用绑定生成函数的第一个参数传递到std::placeholders::_1所在位置（如上，绑定生成的函数output_3，调用时output_3(3)，此时会将参数3传递到std::bind(output_2,100,<strong>3</strong>)，接着会解析成output_2(100,3)，以此类推std::placeholders::_2。</li>
</ol>
<p>std::bind绑定器的作用：</p>
<ol>
<li>将可调用对象与其参数一起绑定成一个仿函数。</li>
<li>将多元（参数个数为n，n&gt;1）可调用对象转换成一元或者（n-1）元可调用对象，即部分参数绑定。</li>
</ol>
<p>绑定一个成员函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"\t"</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; fr = <span class="built_in">std</span>::bind(&amp;A::output,&amp;a,<span class="built_in">std</span>::placeholders::_1,<span class="built_in">std</span>::placeholders::_2);</span><br><span class="line">	fr(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="number">1</span>	<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码可以看出：</p>
<ol>
<li>std::bind的返回值是std::function；</li>
<li>std::bind绑定成员函数时，第一参数是成员函数指针，第二参数是对象指针（相当于将this指针作为第一个参数传递给成员函数，在C++中，这通常是一个隐含参数），这也就将成员函数和对象绑定了，第三给参数是传递给成员函数的第一个参数，以此类推其他参数。</li>
</ol>
<p>知道std::bind绑定类成员的方法，我们就可利用这个方法来解决：std::function函数包装器不能容纳类成员函数指针问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Bar</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a &amp; <span class="number">0x01</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> FuncTest</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; callback_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	FuncTest(<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; func):callback_(func)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(callback_(i))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Bar bar;</span><br><span class="line">	<span class="keyword">auto</span> fr = <span class="built_in">std</span>::bind(&amp;Bar::isEven,&amp;bar,<span class="built_in">std</span>::placeholders::_1);</span><br><span class="line">		</span><br><span class="line">	<span class="function">FuncTest <span class="title">ft1</span><span class="params">(fr)</span></span>;</span><br><span class="line">	ft1.output();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>问题得到解决。</p>
<p>std::bind的组合使用<br>使用绑定器和逻辑函数将多个函数组合成一个复合函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::placeholders::_1;</span><br><span class="line"><span class="keyword">auto</span> func = <span class="built_in">std</span>::bind(<span class="built_in">std</span>::logical_and&lt;boo&gt;(),</span><br><span class="line">					  <span class="built_in">std</span>::bind(<span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">5</span>),</span><br><span class="line">		  			  <span class="built_in">std</span>::bind(<span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">10</span>)</span><br><span class="line">		 			 );</span><br><span class="line"><span class="comment">// 查找集合中大于5小于10的元素个数</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="built_in">std</span>::count_if(container.begin(),container.end(),func);</span><br></pre></td></tr></table></figure></p>
<h3 id="lambda表达式">lambda表达式</h3><p>知道可调用对象之后，我们在传递一个可调用对象的时候就可以定义一个可调用对象传递过去，但是对于一些复用次数不多，处理过程简单的处理代码，为此特意定义一个可调用对象，显得大材小用。lambda就能很好的解决这个问题。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可调用对象版，使用仿函数</span></span><br><span class="line"><span class="keyword">class</span> Even</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(a &amp; <span class="number">0x01</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">Even isEven;</span><br><span class="line">for_each(vec.begin(), vec.end(), isEven);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda版</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">for_each(vec.begin(), vec.end(), [](<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(a &amp; <span class="number">0x01</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，lambda表达式使代码更可读，更简洁，上例或许还看不出多少简洁成分，可以看下例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找集合中大于5小于10的元素个数，std::function和std::bind版本</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::placeholders::_1;</span><br><span class="line"><span class="keyword">auto</span> func = <span class="built_in">std</span>::bind(<span class="built_in">std</span>::logical_and&lt;boo&gt;(),</span><br><span class="line">					  <span class="built_in">std</span>::bind(<span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">5</span>),</span><br><span class="line">		  			  <span class="built_in">std</span>::bind(<span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">10</span>)</span><br><span class="line">		 			 );</span><br><span class="line"><span class="keyword">int</span> count = <span class="built_in">std</span>::count_if(container.begin(),container.end(),func);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找集合中大于5小于10的元素个数，lambda版本</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="built_in">std</span>::count_if(container.begin(),container.end(),[](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x &gt; <span class="number">5</span> &amp;&amp; x &lt; <span class="number">10</span>;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>lambda表达式源于函数式编程的概念，有如下优点：</p>
<ol>
<li>声明式编程风格：就地定义匿名目标函数或函数对象（即可调用对象）；</li>
<li>简洁：不需要定义具名函数或者函数对象；</li>
<li>在需要的时间和地点实现功能闭包，使程序更灵活。</li>
</ol>
<h4 id="lambda表达式概念">lambda表达式概念</h4><p>lambda语法格式：<br>[ capture ] ( params ) opt -&gt; ret { body; };<br>说明：</p>
<ol>
<li>captura是捕获列表；</li>
<li>params是参数列表，在参数列表没有参数时，可以省略参数列表（包括左右括号）；</li>
<li>opt是函数选项，如mutable；</li>
<li>ret是返回值类型，可以根据returned语句自动推导返回值类型，但是初始化列表不能用于推导，此时要显示写明返回值类型；</li>
<li>body是函数体。</li>
</ol>
<p>捕获列表可以如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">捕获列表</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[]</td>
<td style="text-align:center">不捕获任何变量</td>
</tr>
<tr>
<td style="text-align:center">[&amp;]</td>
<td style="text-align:center">以引用的方式捕获外部作用域中的所有变量</td>
</tr>
<tr>
<td style="text-align:center">[=]</td>
<td style="text-align:center">以值的方式捕获外部作用域中的所有变量</td>
</tr>
<tr>
<td style="text-align:center">[=,&amp;foo]</td>
<td style="text-align:center">按值捕获外部作用域中的所有变量，按引用捕获foo</td>
</tr>
<tr>
<td style="text-align:center">[foo]</td>
<td style="text-align:center">只按值捕获foo，其他变量都不捕获</td>
</tr>
<tr>
<td style="text-align:center">[this]</td>
<td style="text-align:center">捕获当前类中的this指针，与类成员函数一样的访问权限，[&amp;]或[=]包括this在内</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ol>
<li><p><strong>按值捕获的变量是在定义lambda表达式时变量的复制品，当外部作用域改变该值时，不影响lambda中捕获的值</strong>。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> func = [=]&#123;<span class="keyword">return</span> a;&#125;;				<span class="comment">//按值捕获</span></span><br><span class="line"></span><br><span class="line">a += <span class="number">1</span>;									<span class="comment">//修改外部值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func() &lt;&lt; <span class="built_in">std</span>::endl;		<span class="comment">//输出是0，不是1，因为func中是按值a,捕获的a其实是a的一个复制品，外部值改变不影响lambda这个闭包中的值。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>按值捕获的变量，在lambda中无法修改，如需修改，添加函数选项mutable，但是由于是按值捕获，在lambda中修改捕获值也不会影响外部变量的值，使用mutable时，就算没有参数参数列表也不能省略</strong>。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> func1 = [=]&#123;<span class="keyword">return</span> a++;&#125;;				<span class="comment">//error,无法修改</span></span><br><span class="line"><span class="keyword">auto</span> func2 = [=]() <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> a++;&#125;;	<span class="comment">//ok，mutable可以修改</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>lambda表达式类型在C++11中称为“闭包类型”，它是一种特殊的、匿名的非non-union的类类型。我们可以将它看作一个带有operator()的类，即仿函数。它可以使用std::function和std::bind来存储和操作lambda表达式。在上文中说道std::function函数包装器可以接收<strong>函数指针</strong>、<strong>仿函数</strong>、<strong>静态成员函数指针</strong>，现在还可以加上<strong>lambda表达式</strong>。例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func1 = [](<span class="keyword">int</span> a)&#123; <span class="keyword">return</span> a;&#125;;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func2 = <span class="built_in">std</span>::bind([](<span class="keyword">int</span> a)&#123;<span class="keyword">return</span> a;&#125;,<span class="built_in">std</span>::placeholders::_1);</span><br></pre></td></tr></table></figure></p>
<p>lambda表达式可以说是就地定义仿函数闭包的“语法糖”，它捕获的变量成为了闭包成员变量。按照C++标准，lambda表达式的operator()默认是const的，所以无法修改捕获到的变量。如果将lambda表达转换成函数指针，此时会丢失lambda闭包的this指针，对于无捕获列表的lambda表达式没什么问题，但是对于有捕获列表的将会报错，编译通不过。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*ptr)</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line">ptr p1 = [](<span class="keyword">int</span>* p) &#123;<span class="keyword">delete</span> p;&#125;;	<span class="comment">//ok</span></span><br><span class="line">ptr p2 = [&amp;](<span class="keyword">int</span> *p) &#123;<span class="keyword">delete</span> p;&#125;;	<span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>C++11引入函数表达式，让代码更简洁，更灵活，更强大，挺提高了开发效率和提高了可维护性。</p>
<h3 id="tuple元组">tuple元组</h3><p>tuple元组是一个固定大小的不同类型值的集合，是泛化的std::pair。</p>
<ol>
<li>构造tuple：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tp(<span class="number">1</span>,<span class="number">2</span>);	<span class="comment">//ok</span></span><br><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tp&#123;<span class="number">1</span>,<span class="number">2</span>);	<span class="comment">//ok</span></span><br><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tp = &#123; <span class="number">1</span>, <span class="number">2</span>&#125;;	<span class="comment">//error,tuple构造函数被explicit限定</span></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line">tuple&lt;<span class="keyword">const</span> <span class="keyword">char</span>*,<span class="keyword">int</span>&gt; tp = <span class="built_in">std</span>::make_tuple(sendPack,nSendSize);</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> *pack;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：</span></span><br><span class="line"><span class="keyword">auto</span> tp = <span class="keyword">return</span> <span class="built_in">std</span>::tie(<span class="number">1</span>,<span class="string">"aa"</span>,<span class="number">2</span>);	<span class="comment">//实际类型：std::tuple&lt;int&amp;,string&amp;,int&amp;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法四：</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"aa"</span>;</span><br><span class="line"><span class="keyword">auto</span> tp = <span class="built_in">std</span>::make_tuple(ref(a),ref(s),ref(b));	<span class="comment">//实际类型：std::tuple&lt;int&amp;,string&amp;,int&amp;)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>说明：tuple构造函数被explicit限定，不能进行隐式转换，不可以将初始化列表传至“期望获取一个tuple”的地方，而是使用make_tuple。通过std::tie创建的元组是一个左值引用元组。</p>
<ol>
<li><p>获取元组值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* data = get&lt;<span class="number">0</span>&gt;(tp);</span><br><span class="line"><span class="keyword">int</span> len = get&lt;<span class="number">1</span>&gt;(tp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">string</span> a;</span><br><span class="line"><span class="built_in">std</span>::tie(x,a,y) = tp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果只想获取某个值</span></span><br><span class="line"><span class="built_in">std</span>::tie(<span class="built_in">std</span>::ignore,<span class="built_in">std</span>::ignore,y) = tp;	<span class="comment">//只取第三个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">string</span> a;</span><br><span class="line"><span class="built_in">std</span>::make_tuple(ref(x),ref(a),ref(y)) = tp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接多个tuple元组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// printtuple.h file</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> IDX, <span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> PRINT_TUPLE&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; strm, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Args...&gt;&amp; t)</span></span>&#123;</span><br><span class="line">		strm &lt;&lt; <span class="built_in">std</span>::get&lt;IDX&gt;(t) &lt;&lt; (IDX+<span class="number">1</span>==MAX ? <span class="string">""</span> : <span class="string">","</span>);</span><br><span class="line">		PRINT_TUPLE&lt;IDX+<span class="number">1</span>,MAX,Args...&gt;::print(strm,t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化类模版，终结递归调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> PRINT_TUPLE&lt;MAX,MAX ,Args...&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; strm, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Args...&gt;&amp; t)</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (<span class="built_in">std</span>::ostream&amp; strm, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Args...&gt;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	strm &lt;&lt; <span class="string">"["</span>;</span><br><span class="line">	PRINT_TUPLE&lt;<span class="number">0</span>,<span class="keyword">sizeof</span>...(Args),Args...&gt;::print(strm,t);</span><br><span class="line">	<span class="keyword">return</span> strm &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// testtuple.cpp file</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"printtuple.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">float</span>&gt; t1(<span class="number">1</span>, <span class="string">"bb"</span>, <span class="number">1.23</span>);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> t2 = <span class="built_in">std</span>::tuple_cat(t1,<span class="built_in">std</span>::make_pair(<span class="string">"cc"</span>,<span class="string">"dd"</span>), <span class="built_in">std</span>::tie(n));</span><br><span class="line">        n = <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t2 &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line">[<span class="number">1</span>,bb,<span class="number">1.23</span>,cc,dd,<span class="number">20</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>从上面可以看出std::tie构造或者解构都是引用，std::make_tuple和std::ref组合使用能做到std::tie的效果。tuple无法直接输出，自己重载&lt;&lt;函数对tuple进行输出。</p>
<p>tuple虽然可以用来代替简单的结构体，但是不要滥用，否则会导致代码的可读性下降。</p>
<h3 id="小结">小结</h3><p>至此，使用C++11特性简化代码，使得代码更方便、简洁和优雅，特性有：类型推导（auto、decltype），模板别名和模板函数默认参数，基于范围的for循环，统一的初始化列表，函数包装器和函数绑定器，lambda表达式，tuple元组。</p>
<h3 id="参考资料">参考资料</h3><ol>
<li>《深入应用C++11：代码优化和工程应用》</li>
<li>《C++ Primer》（第五版）</li>
<li>《C++标准库》（第二版）</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="基于范围的for循环">基于范围的for循环</h3><p>基于范围的for循环非常的简洁，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : arr)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++98/03版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = arr.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; it != arr.end(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相比之下，C++版本更加简洁。</p>
<h4 id="基于范围的for循环使用细节">基于范围的for循环使用细节</h4><p>注意到基于范围的for循环中的auto n，推导出来的是int类型，也就是说<strong>auto推导出来的类型是容器的value_type，而不是迭代器</strong>。</p>
<p>看到for (auto n : arr)这句，有人会怀疑对容器的访问是没取一个值访问一次容器。事实真是这样吗？我们可以用下面的代码验证一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; get_range(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val : get_range())</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line">get_range</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="C++11" scheme="http://hanhaichensha.coding.me/tags/C-11/"/>
    
      <category term="C++" scheme="http://hanhaichensha.coding.me/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++11特性与应用（二）]]></title>
    <link href="http://hanhaichensha.coding.me/2016/08/04/C-11%E7%89%B9%E6%80%A7%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://hanhaichensha.coding.me/2016/08/04/C-11特性与应用（二）/</id>
    <published>2016-08-04T07:38:22.000Z</published>
    <updated>2016-11-04T05:54:16.090Z</updated>
    <content type="html"><![CDATA[<h3 id="模板细节">模板细节</h3><h4 id="模板右尖括号">模板右尖括号</h4><p>在C++98/03范型编程中，模板实例的两个连续右尖括号之间必须加一空格，以免和右移操作符混淆。在C++11中这种限制取消了，不过，要注意的一点是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Foo&lt;<span class="number">100</span> &gt;&gt; <span class="number">2</span>&gt; x;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在c++98/03中编译是么有问题的，它将Foo<100>&gt; 2&gt; x理解为Foo&lt;(100 &gt;&gt; 2)&gt; x。但是在C++中编译器会提示错误，因为100 &gt;&gt; 2会先解释为模板的定界符，所以要手动写上括号Foo&lt;(100 &gt;&gt; 2)&gt; x。</100></p>
<h4 id="模板的别名">模板的别名</h4><p><strong>类型别名</strong>是一个名字，它是某种类型的同义词。有两种方法可以定义类型别名，一是传统方法使用关键字<strong>typedef</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>typedef只是为某种类型取别名，并没有真的定义一种新的类型，因此，下面这样将不是合法的函数重载：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(uint_t)</span></span>;			<span class="comment">//error:重定义</span></span><br></pre></td></tr></table></figure></p>
<p>假如我们要定义一个map类型，它的key是固定类型std::string，值可以是int也可以是std::string等类型，该如何定义这么一种类型的map呢？在C++98/03中，可以如下实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">struct</span> str_map</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">str_map&lt;<span class="keyword">int</span>&gt;::type map1;		<span class="comment">//key是std::string，值是int</span></span><br><span class="line">str_map&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::type map2	<span class="comment">//key是std::string，只是std::string</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>使用C++11的新语法，会使得简洁易懂，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">str_map_t</span> = <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,Val&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">str_map_t</span>&lt;<span class="keyword">int</span>&gt; map1;			<span class="comment">//key是std::string，值是int</span></span><br><span class="line"><span class="keyword">str_map_t</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; map2;	<span class="comment">//key是std::string，值是std::string</span></span><br></pre></td></tr></table></figure></p>
<p>这种方法叫<strong>别名声明</strong>，同样，别名声明也没有定义新的类型。实际上，using的别名语法覆盖了typedef的全部功能。using定义的str_map_t是一个模板，但是它既不是函数模板，也不是类模板，而是一种新的模板形式：<strong>模板别名</strong>。</p>
<h4 id="函数模板的默认模板参数">函数模板的默认模板参数</h4><p>在C++98/03中，类模板可以有默认的模板参数，但是函数模板不支持默认参数，在C++11中这种限制被解除了。当所有模板参数都有默认值时，函数模板的调用如同调用普通函数，而对于类模板，即使参数都有默认值，在使用的时候也一定要加“&lt;&gt;”来实例化对象。函数模板的默认模板参数在使用规则上和其他的默认参数有所不同，它没有必要卸载参数列表的最后面。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"type_name.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R = <span class="keyword">int</span>,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">func</span><span class="params">(U val)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(val)&gt;() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	reuturn val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	func(<span class="number">123</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(func(<span class="number">123</span>))&gt;() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	func(<span class="number">123L</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(func(<span class="number">123L</span>))&gt;() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	func&lt;<span class="keyword">long</span>&gt;(<span class="number">123</span>)</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(func&lt;<span class="keyword">long</span>&gt;(<span class="number">123</span>))&gt;() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">int</span>			<span class="comment">//func(123)，val类型是int,即U是int</span></span><br><span class="line"><span class="keyword">int</span>			<span class="comment">//decltype(func(123))是函数返回类型R,默认int</span></span><br><span class="line"><span class="keyword">long</span>		<span class="comment">//func(123L),val类型是long，即U是long</span></span><br><span class="line"><span class="keyword">int</span>			<span class="comment">//decltype(func(123L))是函数返回类型R,默认int</span></span><br><span class="line"><span class="keyword">int</span>			<span class="comment">//func&lt;long&gt;(123)，val类型是int,即U是int</span></span><br><span class="line"><span class="keyword">long</span>		<span class="comment">//decltype(func&lt;long&gt;(123))是函数返回类型R,根据模板参数是long</span></span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，由于函数调用时，参数是从右往左填充，此时根据func(123)，推导出U是int，R使用默认值；decltype(func<long>(123))函数参数是123推导出U是int，模板参数是long，所以R是long。</long></p>
<h3 id="初始化列表">初始化列表</h3><p>C++11中能够使用初始化列表进行初始化的只有<strong>聚合类型</strong>。什么是聚合类型呢？聚合类型的定义如下：</p>
<ol>
<li>类型是一个普通数组（如int[1],char[2],long[3][4]）；</li>
<li>类型是一个类（class，struct，union），且<br>1）、无用户自定义的构造函数；<br>2）、无私有(private)或者保护(protected)的非静态数据成员；<br>3）、无基类；<br>4）、无虚函数；<br>5）、不能有{}和=直接初始化的非静态数据成员。</li>
</ol>
<p>例一：普通数组<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">float</span> y[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">	&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">	&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>例二：类类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line">	Foo(<span class="keyword">int</span>,<span class="keyword">int</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Foo foo&#123;<span class="number">1</span>,<span class="number">2.5</span>,<span class="number">1</span>&#125;;	<span class="comment">//error:有用户自定义构造函数，与1）不符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ST</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line">ST s&#123;<span class="number">1</span>,<span class="number">2.5</span>,<span class="number">1</span>&#125;;		<span class="comment">//error:有私有或保护的非静态成员，与2）不符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line">Foo foo&#123;<span class="number">1</span>,<span class="number">2.5</span>&#125;;		<span class="comment">//ok,虽有保护成员，但是是静态成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ST</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ST s&#123;<span class="number">1</span>,<span class="number">2.5</span>&#125;;		<span class="comment">//error,有虚函数，与4）不符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Base &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> Foo : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">Foo foo &#123; <span class="number">1</span>, <span class="number">2.5</span> &#125;;	<span class="comment">//error，有基类，与3）不符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ST</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">double</span> y = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">ST s &#123; <span class="number">1</span>, <span class="number">2.5</span> &#125;;	<span class="comment">//error，有直接初始化的非静态数据成员，与5）不符；注意，在C++11中可以在声明非静态成员变量时进行初始化（使用&#123;&#125;或者=）。</span></span><br></pre></td></tr></table></figure></p>
<p>对于上述非聚合类型，可以定义自定义构造函数来使用初始化列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ST</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">F</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ST(<span class="keyword">int</span> i,<span class="keyword">double</span> j,<span class="keyword">int</span> k):x(i),y(j),z(k)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ST s &#123; <span class="number">1</span>,<span class="number">2.5</span>,<span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意：聚合类型的定义并非递归的，当一个类的非静态成员是非聚合类型时，这个类也是有可能是聚合类型。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ST</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line">ST s &#123; <span class="number">1</span>, <span class="number">2.5</span>, <span class="number">1</span> &#125;;		<span class="comment">//error，这是一个非聚合类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">	ST st;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">Foo foo &#123; &#123;&#125;, <span class="number">1</span>, <span class="number">2.5</span> &#125;;		<span class="comment">//ok，虽然ST是非聚合类型，但是Foo是聚合类型，初始化列表中的&#123;&#125;调用了ST的默认构造函数</span></span><br></pre></td></tr></table></figure></p>
<h4 id="任意长度同类型初始化列表">任意长度同类型初始化列表</h4><p>在C++中，定义并初始化数组时，可以不指定数组长度，通过初始化列表来确定数组长度：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>同理，可以stl中的容器std::initializer_list这个轻量级类模板来实现自定义类型的任意长度同类型初始化列表，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; content_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo( <span class="built_in">std</span>::initializer_list&lt;<span class="keyword">int</span>&gt; li)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = li.begin(); it != li.end(); ++it)</span><br><span class="line">		&#123;</span><br><span class="line">			content_.pushback(*it);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Foo foo = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;		<span class="comment">//ok</span></span><br></pre></td></tr></table></figure></p>
<p>std::initializer_list不仅可以用来对自定义类型初始化，还可以用来传递同类型的数据集合，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">( <span class="built_in">std</span>::initializer_list&lt;<span class="keyword">int</span>&gt; li)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = li.begin(); it != li.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	func(&#123;&#125;);</span><br><span class="line">	func(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>std::initializer_list特点：</p>
<ol>
<li>它是一个轻量级的容器类型，内部定义了iterator等；</li>
<li>对于std::initializer_list<t>，可以接收任意长度的同类型（或者相容类型）初始化列表元素；</t></li>
<li>对外提过：size()、begin()和end()三个接口；</li>
<li>它只能被整体初始化或赋值。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::initializer_list&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;	<span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">size_t</span> n = <span class="built_in">list</span>.size();				<span class="comment">//size为0</span></span><br><span class="line"><span class="built_in">list</span> = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;					<span class="comment">//使用初始化列表赋值</span></span><br><span class="line">n = <span class="built_in">list</span>.size();					<span class="comment">//size为3</span></span><br><span class="line"><span class="built_in">list</span> = &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span> &#125;;				<span class="comment">//使用初始化列表重新赋值</span></span><br><span class="line">n = <span class="built_in">list</span>.size();					<span class="comment">//size为4</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对于std::initializer_list和vector容器的性能相比，std::initializer_list对初始化列表元素的引用，并没有真正拷贝元素，而std::vector是拷贝元素，所以std::initializer_list的性能更好。因为是只是引用，所以在函数返回值时，尽量不要使用std::initializer_list，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::initializer_list&lt;<span class="keyword">int</span>&gt; func(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> &#123; a, b &#125;;	<span class="comment">//由于是引用，函数返回后， a和b的生命期都结束了，返回得到的将会是不确定的内容。此时使用std::vector更妥当。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化列表能防止类型收窄，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1.1</span>;		<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span> b = &#123; <span class="number">1.1</span> &#125;;	<span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>类型收窄的情况：</p>
<ol>
<li>浮点数向整数隐式转换；</li>
<li>从高精度向低精度隐式转换；</li>
<li>从大整数向浮点数隐式转换；</li>
<li>从整数向长度更短的整数隐式转换。</li>
</ol>
<h3 id="参考资料">参考资料</h3><ol>
<li>《深入应用C++11：代码优化和工程应用》</li>
<li>《C++ Primer》（第五版）</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="模板细节">模板细节</h3><h4 id="模板右尖括号">模板右尖括号</h4><p>在C++98/03范型编程中，模板实例的两个连续右尖括号之间必须加一空格，以免和右移操作符混淆。在C++11中这种限制取消了，不过，要注意的一点是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Foo&lt;<span class="number">100</span> &gt;&gt; <span class="number">2</span>&gt; x;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在c++98/03中编译是么有问题的，它将Foo<100 >&gt; 2&gt; x理解为Foo&lt;(100 &gt;&gt; 2)&gt; x。但是在C++中编译器会提示错误，因为100 &gt;&gt; 2会先解释为模板的定界符，所以要手动写上括号Foo&lt;(100 &gt;&gt; 2)&gt; x。</p>
<h4 id="模板的别名">模板的别名</h4><p><strong>类型别名</strong>是一个名字，它是某种类型的同义词。有两种方法可以定义类型别名，一是传统方法使用关键字<strong>typedef</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>typedef只是为某种类型取别名，并没有真的定义一种新的类型，因此，下面这样将不是合法的函数重载：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(uint_t)</span></span>;			<span class="comment">//error:重定义</span></span><br></pre></td></tr></table></figure></p>
<p>假如我们要定义一个map类型，它的key是固定类型std::string，值可以是int也可以是std::string等类型，该如何定义这么一种类型的map呢？在C++98/03中，可以如下实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">struct</span> str_map</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">str_map&lt;<span class="keyword">int</span>&gt;::type map1;		<span class="comment">//key是std::string，值是int</span></span><br><span class="line">str_map&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::type map2	<span class="comment">//key是std::string，只是std::string</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="C++11" scheme="http://hanhaichensha.coding.me/tags/C-11/"/>
    
      <category term="C++" scheme="http://hanhaichensha.coding.me/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++11特性与应用（一）：C++11语言特性]]></title>
    <link href="http://hanhaichensha.coding.me/2016/08/01/C-11%E7%89%B9%E6%80%A7%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AC-11%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    <id>http://hanhaichensha.coding.me/2016/08/01/C-11特性与应用（一）：C-11语言特性/</id>
    <published>2016-08-01T10:21:27.000Z</published>
    <updated>2016-11-04T05:54:16.084Z</updated>
    <content type="html"><![CDATA[<p>C++11相对于C++98/03有一下几点显著增强：</p>
<ol>
<li>通过内存模型、线程、原子操作等来支持本地并行编程；</li>
<li>通过统一初始化表达式、auto、decltype、移动语义等来统一对泛型编程的支持；</li>
<li>通过constexpr、POD（概念）等更好地支持系统编程；</li>
<li>通过内联命名空间、继承构造函数和右值引用等，以更好地支持库的构建。</li>
</ol>
<h2 id="1、C++11改进我们的程序">1、C++11改进我们的程序</h2><h3 id="1-1_类型推导">1.1 类型推导</h3><h3 id="1、auto类型推导">1、auto类型推导</h3><p>编程时常常需要把表达式赋值给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11引入了<strong>auto</strong>类型说明符，用它就能让编译器（说明这个过程是编译阶段完成）替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符不同，auto让编译器通过初始值来推算变量的类型。显然，<strong>auto定义的变量必须有初始值</strong>。</p>
<h4 id="顶层const和底层const">顶层const和底层const</h4><p>我们都知道指针本身是一个对象，它又可以指向另一个对象。因此，指针本身是不是常量和指针所指向的对象是不是常量就是两个相互独立的问题。用名词<strong>顶层const（top-level const）</strong>表示指针本身是一个常量，而<strong>底层const（low-level const）</strong>表示指针所指向的对象是一个常量。</p>
<p>更一般的，<strong>顶层const</strong>可以表示任意的对象本身是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。<strong>底层const</strong>则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点与其他类型相比区别明显：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;		<span class="comment">//不能改变p1的值，这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;		<span class="comment">//不能改变ci的值，这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;	<span class="comment">//允许改变p2的值，这是一个底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3=p2; <span class="comment">//右边的const是顶层const，左边的const是底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;		<span class="comment">//用于声明引用的const都是底层const</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h4 id="推导规则：">推导规则：</h4><ol>
<li>当不声明为指针或引用时，auto的推到结果和初始化表达式抛弃引用和cv（const和volatile限定符）限定符后类型一致，就是抛弃引用和顶层的cv；</li>
<li>当声明为指针或引用时，auto的推导结果将保持初始表达式的cv属性，也就是保存底层cv。</li>
</ol>
<p>例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> *a = &amp;x;			<span class="comment">//a -&gt;int *</span></span><br><span class="line"><span class="keyword">auto</span>  b = &amp;x;			<span class="comment">//b -&gt;int *</span></span><br><span class="line"><span class="keyword">auto</span> &amp;c =  x;			<span class="comment">//c -&gt;int &amp;</span></span><br><span class="line"><span class="keyword">auto</span>  d =  c;			<span class="comment">//d -&gt;int,根据规则1,丢掉了引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> e = x;		<span class="comment">//e -&gt;const int</span></span><br><span class="line"><span class="keyword">auto</span> f = e;				<span class="comment">//f -&gt;int,根据规则1,丢到了const</span></span><br><span class="line"><span class="keyword">auto</span> i = &amp;e;			<span class="comment">//i -&gt;const int *,根据规则2,保持const属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;g = x;		<span class="comment">//g -&gt;const int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = g;			<span class="comment">//h -&gt;const int &amp;,根据规则2,保持const属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> *v = &amp;x, u = <span class="number">6</span>;		<span class="comment">//OK,v是const int*类型，u是const int类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> *m = &amp;x, n = <span class="number">6.0</span>;	<span class="comment">//error,从m推导出auto是int，从n推导出auto是double，产生二义性</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">int</span> r;						<span class="comment">//error,auto不再表示存储类型指示符</span></span><br><span class="line"><span class="keyword">auto</span> s;							<span class="comment">//error,auto只是占位符，并不代表实际类型，必须要有初始值</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意以下几点：</p>
<ol>
<li>const auto *v=&amp;x推导出v的类型是const int *类型，但是u仍然必须要写<strong>u=6</strong>，否则编译通不过。</li>
<li>u的初始化不能是编译器推导产生二义性。例如把u的初始化成<strong>u=6.0</strong>，编译器将会报错。</li>
<li>在旧标准中，auto表示存储类型指示符（包括static，register、mutable等），但是在新标准中auto不再表示存储类型指示符，而是表示为类型指示符，用来提示编译器对变量类型做自动类型推导。</li>
</ol>
<h4 id="auto的限制">auto的限制</h4><ol>
<li>不能用于函数参数类型推导；</li>
<li>不能用于非静态成员变量的类型推导；</li>
<li>不能用于数组类型推导；</li>
<li>不能用于模版参数类型推导；</li>
<li>auto作为函数返回值时，只能用于定义函数，不能用于声明函数;<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> a =<span class="number">1</span>)</span></span>&#123;&#125;				<span class="comment">//error:auto不能用于函数参数类型推导</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> var1_ = <span class="number">0</span>;					<span class="comment">//error:auto不能用于非静态成员变量类型推导</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> var2_ = <span class="number">0</span>;	<span class="comment">//OK:var2_ 是static const int</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> Bar &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> aa     = arr;				<span class="comment">//OK:aa是int *</span></span><br><span class="line">	<span class="keyword">auto</span> rr[<span class="number">10</span>] = arr;				<span class="comment">//error:auto无法定义数组</span></span><br><span class="line">	Bar&lt;<span class="keyword">int</span>&gt; bar;</span><br><span class="line">	Bar&lt;<span class="keyword">auto</span>&gt; bb = bar;				<span class="comment">//error:auto无法推导模版参数类型</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在类中，auto仅能推导出static const的整数类型或者枚举成员，因为其他静态类型在C++标准中无法就地初始化。虽然C++11中可以接受非静态成员变量就地初始化，却不支持auto类型非静态成员变量的初始化。</p>
<h4 id="auto的使用">auto的使用</h4><p>在C++98/03，我们最常用的遍历容器元素操作如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; resultMap;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;::iterator it = resultMap.begin();</span><br><span class="line">	<span class="keyword">for</span> (;it != resultMap.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来看看C++11中使用auto的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; resultMap;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = resultMap.begin(); it != resultMap.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码简洁很多，再也不用写长长的迭代器类型了。</p>
<p>再看一个使用auto简化函数定义的示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bar</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">get</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> val = T::get();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	func&lt;Foo&gt;();</span><br><span class="line">	func&lt;Bar&gt;();</span><br><span class="line">	retunr EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多亏了auto，不然我们就得如下实现func函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	T2 val = T1::get();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	func&lt;Foo,<span class="keyword">int</span>&gt;();</span><br><span class="line">	func&lt;Bar,<span class="keyword">char</span>*&gt;();</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>auto虽然能带来方便，但是如果滥用将会使得代码可读性下降，代码维护难道增大。</p>
<h3 id="2、decltype类型指示符">2、decltype类型指示符</h3><p>有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始变量。在C++11中引入了类型说明符<strong>decltype</strong>，它的作用是选择并返回操作书的数据类型。此过程中，编译器（发生在编译阶段）分析表达式并得到它的类型，却不实际计算表达式的值。而auto只能根据变量的初始化表达式推导出变量应该具有的类型。</p>
<h4 id="decltype(exp)推导规则：">decltype(exp)推导规则：</h4><ol>
<li>exp是标识符、类访问表达式，decltype(exp)和exp的类型一致；</li>
<li>exp是函数调用，decltype(exp)和返回值的类型一致；</li>
<li>其他情况，若exp是左值，则decltype(exp)是exp类型的左值引用，否则和exp类型一致。<br>decltype将精确地推导出表达式定义本身的类型，一般不舍弃引用和cv限定符，只用当函数返回值是非类类型的纯右值时，cv限定符会忽略，因为对于纯右值而言，只用类类型可以携带cv限定符，此外一般忽略掉cv限定。<br>例一：标识符表达式和类访问表达式：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// type_name.h file</span></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> _MSC_VER</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cxxabi.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span></span><br><span class="line"><span class="title">type_name</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type TR;</span><br><span class="line">    <span class="built_in">std</span>::unique_ptr&lt;<span class="keyword">char</span>, <span class="keyword">void</span>(*)(<span class="keyword">void</span>*)&gt; own</span><br><span class="line">           (</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> _MSC_VER</span></span><br><span class="line">                abi::__cxa_demangle(<span class="keyword">typeid</span>(TR).name(), <span class="literal">nullptr</span>,</span><br><span class="line">                                           <span class="literal">nullptr</span>, <span class="literal">nullptr</span>),</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">                <span class="literal">nullptr</span>,</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">free</span></span><br><span class="line">           );</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> r = own != <span class="literal">nullptr</span> ? own.get() : <span class="keyword">typeid</span>(TR).name();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::is_const&lt;TR&gt;::value)</span><br><span class="line">        r = <span class="string">"const "</span> + r;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::is_volatile&lt;TR&gt;::value)</span><br><span class="line">        r = <span class="string">"volatile "</span> + r;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::is_lvalue_reference&lt;T&gt;::value)</span><br><span class="line">        r += <span class="string">"&amp;"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">std</span>::is_rvalue_reference&lt;T&gt;::value)</span><br><span class="line">        r += <span class="string">"&amp;&amp;"</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// type_name.h file end</span></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// decltype1.cpp file</span></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> ”type_name.h“</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Number = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> n1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">decltype</span>(n) n2 = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"n is "</span> &lt;&lt; type_name(n) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"n1 is "</span> &lt;&lt; type_name(n1) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"n2 is "</span> &lt;&lt; type_name(n2) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">int</span> &amp;x = n;</span><br><span class="line">	<span class="keyword">auto</span> x1 = x;</span><br><span class="line">	<span class="keyword">decltype</span>(x) x2 = x;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is "</span> &lt;&lt; type_name(x) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x1 is "</span> &lt;&lt; type_name(x1) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x2 is "</span> &lt;&lt; type_name(x2) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line">	Foo foo;</span><br><span class="line">	<span class="keyword">decltype</span>(foo) c;</span><br><span class="line">	<span class="keyword">decltype</span>(Foo::Number) d = <span class="number">0</span>;</span><br><span class="line">	decltyoe(foo.x) e = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c is "</span> &lt;&lt; type_name(c) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d is "</span> &lt;&lt; type_name(d) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"e is "</span> &lt;&lt; type_name(e) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// decltype1.cpp file end</span></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line">n is <span class="keyword">int</span></span><br><span class="line">n1 is <span class="keyword">int</span></span><br><span class="line">n2 is <span class="keyword">int</span></span><br><span class="line">x is <span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">int</span>&amp;</span><br><span class="line">x1 is <span class="keyword">int</span></span><br><span class="line">x2 is <span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">int</span>&amp;</span><br><span class="line">c is Foo</span><br><span class="line">d is <span class="keyword">const</span> <span class="keyword">int</span></span><br><span class="line">e is <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>auto根据初始化的值类型推导出变量类型，忽略cv限定符，比如x1，而decltype不忽略cv限定符。</p>
<p>例二：函数调用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// decltype2.cpp file</span></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"type_name.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Foo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span>&amp; <span class="title">func_int_r</span><span class="params">(<span class="keyword">void</span>)</span></span>;			<span class="comment">//左值(lvalue)</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">(<span class="keyword">void</span>)</span></span>;		<span class="comment">//x值(xvlalue,右值引用)</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">func_int</span><span class="params">(<span class="keyword">void</span>)</span></span>;				<span class="comment">//纯右值(prvalue)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func_int_r is "</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(func_int_r)&gt;() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func_int_rr is "</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(func_int_rr)&gt;() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func_int is "</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(func_int)&gt;() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">func_cint_r</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">//左值</span></span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">//x值</span></span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">func_cint</span><span class="params">(<span class="keyword">void</span>)</span></span>;		<span class="comment">//纯右值</span></span><br><span class="line">	<span class="function"><span class="keyword">const</span> Foo <span class="title">func_cfoo</span><span class="params">(<span class="keyword">void</span>)</span></span>;		<span class="comment">//纯右值</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func_cint_r() is "</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(func_cint_r)&gt;() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func_cint_rr() is "</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(func_cint_rr)&gt;() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func_cint() is "</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(func_cint)&gt;() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func_cfoo() is "</span> &lt;&lt; type_name&lt;<span class="keyword">decltype</span>(func_cfoo)&gt;() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// decltype2.cpp file end</span></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line">func_int_r() <span class="function">is <span class="keyword">int</span>&amp;</span><br><span class="line"><span class="title">func_int_rr</span><span class="params">()</span> is <span class="keyword">int</span>&amp;&amp;</span><br><span class="line"><span class="title">func_int</span><span class="params">()</span> is <span class="keyword">int</span></span><br><span class="line"><span class="title">func_cint_r</span><span class="params">()</span> is <span class="keyword">const</span> <span class="keyword">int</span>&amp;</span><br><span class="line"><span class="title">func_cint_rr</span><span class="params">()</span> is <span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp;</span><br><span class="line"><span class="title">func_cint</span><span class="params">()</span> is <span class="keyword">int</span></span><br><span class="line"><span class="title">func_cfoo</span><span class="params">()</span> is <span class="keyword">const</span> Foo</span></span><br></pre></td></tr></table></figure></p>
<p>decltype与函数返回值类型一致，但是如果返回值是纯右值<strong>非类类型</strong>，忽略cv限定符，比如：func_cint；如果返回值是纯右值的<strong>类类型</strong>，保留cv限定符。</p>
<p>例3：其他情况，带括号表达式和加法运算表达式：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//////////////////////////////////////</span><br><span class="line">/// decltype3.cpp file</span><br><span class="line">//////////////////////////////////////</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include "type_name.h"</span><br><span class="line"></span><br><span class="line">struct Foo &#123; int x; &#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	const Foo foo = Foo();</span><br><span class="line">	std::cout &lt;&lt; "foo.x is " &lt;&lt; type_name&lt;decltype(foo.x)&gt;() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; "(foo.x) is " &lt;&lt; type_name&lt;decltype((foo.x))&gt;() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	int n = 0,m = 0;</span><br><span class="line">	std::cout &lt;&lt; "n+m is " &lt;&lt; type_name&lt;decltype(n + m)&gt;() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; "n+=m is " &lt;&lt; type_name&lt;decltype(n += m)&gt;() &lt;&lt; std::endl;</span><br><span class="line">	</span><br><span class="line">	return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////</span><br><span class="line">/// decltype3.cpp file end</span><br><span class="line">//////////////////////////////////////</span><br><span class="line"></span><br><span class="line">//////////////////////////////////////</span><br><span class="line">/// output result</span><br><span class="line">//////////////////////////////////////</span><br><span class="line">foo.x is int</span><br><span class="line">(foo.x) is const int&amp;</span><br><span class="line">n+m is int</span><br><span class="line">n+=m is int&amp;</span><br></pre></td></tr></table></figure></p>
<p>foo.x根据推导规则一，类型是int；(foo.x)是左值，推导出是int&amp;，而foo又是const，所以(foo.x)是const int&amp;；n+m是右值，类型是int；n+=m是左值，类型是int&amp;。</p>
<h4 id="decltype应用">decltype应用</h4><p>decltype的应用多出现在泛型编程中。</p>
<p>应用一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ContainerT&gt;</span><br><span class="line"><span class="keyword">class</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typename</span> ContainerT::iterator it_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ContainerT&amp; container)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		it_ = container.begin();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="keyword">container_t</span>;</span><br><span class="line">	<span class="keyword">container_t</span> arr;</span><br><span class="line">	</span><br><span class="line">	Foo&lt;<span class="keyword">container_t</span>&gt; foo;</span><br><span class="line">	foo.func(arr);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>单独看vector没有什么问题，但是如果传入的容器有const限定，那么就会出问题了，因为const容器的迭代器是const_iterator。在C++98/03中的解决方案是，特化一个类模版如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ContainerT&gt;</span><br><span class="line"><span class="keyword">class</span> Foo&lt;<span class="keyword">const</span> ContainerT&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typename</span> ContainerT::const_iterator it_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> ContainerT&amp; container)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		it_ = container.begin();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的实现略显繁琐，在C++11中只要稍微修改一下类模版Foo即可实现相同功能，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ContainerT&gt;</span><br><span class="line"><span class="keyword">class</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">decltype</span>(ContainerT().begin()) it_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ContainerT&amp; container)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		it_ = container.begin();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样无论容器是否被const限定都没问题，代码简洁了好多。</p>
<h3 id="auto和decltype结合使用：返回类型后置语法">auto和decltype结合使用：返回类型后置语法</h3><p>在范型编程中，可能需要通过参数的运算来得到返回值类型。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(t+u) add(T t,U u)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这样编译不过，因为t、u在参数列表中，C++的返回值是前置语法，返回值定义的时候参数变量还不存在。不过可以改成如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(T()+U()) add(T t,U u)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样看上去没什么问题，但是如果T和U类型没有无参构造函数，依然会有问题，还可以改成下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>((*(T*)<span class="number">0</span>) + (*(U*)<span class="number">0</span>)) add(T t,U u)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样确实已经实现了此功能，但是看上去和复杂，而且让人费解，如果使用auto和decltype结合使用可以和简洁的完成此功能：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,typename U&gt;</span><br><span class="line">auto add(T t,U u) -&gt; decltype(t+u)</span><br><span class="line">&#123;</span><br><span class="line">	return t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>auto会根据后置的decltype(t+u)类型推导出来，而此时t和u的已经存在，所以没有问题，代码也很简洁，可读性强。</p>
<h3 id="参考资料">参考资料</h3><ol>
<li>《深入应用C++11：代码优化和工程应用》</li>
<li>《C++ Primer》（第五版）</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>C++11相对于C++98/03有一下几点显著增强：</p>
<ol>
<li>通过内存模型、线程、原子操作等来支持本地并行编程；</li>
<li>通过统一初始化表达式、auto、decltype、移动语义等来统一对泛型编程的支持；</li>
<li>通过constexpr、POD（概念）等更好地支持系统编程；</li>
<li>通过内联命名空间、继承构造函数和右值引用等，以更好地支持库的构建。</li>
</ol>
<h2 id="1、C++11改进我们的程序">1、C++11改进我们的程序</h2><h3 id="1-1_类型推导">1.1 类型推导</h3><h3 id="1、auto类型推导">1、auto类型推导</h3><p>编程时常常需要把表达式赋值给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11引入了<strong>auto</strong>类型说明符，用它就能让编译器（说明这个过程是编译阶段完成）替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符不同，auto让编译器通过初始值来推算变量的类型。显然，<strong>auto定义的变量必须有初始值</strong>。</p>
<h4 id="顶层const和底层const">顶层const和底层const</h4><p>我们都知道指针本身是一个对象，它又可以指向另一个对象。因此，指针本身是不是常量和指针所指向的对象是不是常量就是两个相互独立的问题。用名词<strong>顶层const（top-level const）</strong>表示指针本身是一个常量，而<strong>底层const（low-level const）</strong>表示指针所指向的对象是一个常量。</p>
<p>更一般的，<strong>顶层const</strong>可以表示任意的对象本身是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。<strong>底层const</strong>则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点与其他类型相比区别明显：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;		<span class="comment">//不能改变p1的值，这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;		<span class="comment">//不能改变ci的值，这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;	<span class="comment">//允许改变p2的值，这是一个底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3=p2; <span class="comment">//右边的const是顶层const，左边的const是底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;		<span class="comment">//用于声明引用的const都是底层const</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="C++11" scheme="http://hanhaichensha.coding.me/tags/C-11/"/>
    
      <category term="C++" scheme="http://hanhaichensha.coding.me/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++11并发编程（一）]]></title>
    <link href="http://hanhaichensha.coding.me/2016/07/22/C-11%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BD%A0%E5%A5%BD%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%96%E7%95%8C/"/>
    <id>http://hanhaichensha.coding.me/2016/07/22/C-11并发编程（一）：你好，并发世界/</id>
    <published>2016-07-22T06:33:15.000Z</published>
    <updated>2016-11-04T05:54:16.080Z</updated>
    <content type="html"><![CDATA[<h2 id="1-1_何谓并发">1.1 何谓并发</h2><p>最简单和最基本的并发是指两个或更多独立的活动同时发生，在计算机领域，并发指的是在单个系统里同时执行多个独立任务。</p>
<p>计算机并发物理方式：多核并行、单核任务切换以及多核任务切换。</p>
<h3 id="1-1-2_并发的途径">1.1.2 并发的途径</h3><p>并发的两种基本途径：多进程并发和多线程并发。</p>
<h4 id="多进程并发">多进程并发</h4><p>将应用程序分为多个独立的进程，使其同时运行，进程间通过常规的通信渠道传递消息（包括信号、套接字、文件、管道等等）。</p>
<p>缺点：</p>
<ol>
<li>通信设置复杂或者通信速度慢（慢的原因是操作系统的进程安全保护措施，避免一个进程去修改另一个进程的数据）；</li>
<li>进程消耗的资源大，主要表现为启动时间长，操作系统需要消耗资源来管理进程。</li>
</ol>
<p>优点：</p>
<ol>
<li>由于操作系统为进程间提供了附加保护操作和更高级别的通信机制，从而能够更容易的编写出安全的并发代码；</li>
<li>通过网络，使用远程连接方式，在不同机器上运行独立的进程，虽然增加了通信成本，但在设计精良的系统上，这是一个提高并行可用性和性能的低成本方式。<a id="more"></a>
<h4 id="多线程并发">多线程并发</h4>在单个进程中运行多个相互独立的线程，且线程可以在不同的指令序列中运行，同一进程中的所有线程都是共享地址空间，并且所有线程能访问大部分数据（全局变量仍是全局的，指针、对象的引用或数据可以在线程之间传递）。进程间虽然也能做到共享内存，但是这种共享通常很难建立，因为，同一数据的内存地址在不同进程中是不同的。</li>
</ol>
<p>优点：地址空间共享，以及缺少线程间数据的保护，减少了操作系统的记录工作，从而是的多线程开销远小于多进程。</p>
<p>缺点：同时，由于是共享内存以及缺少进程间数据的保护，如果数据要被多个线程访问，那么程序员必须保证数据的一致性，从而影响了程序员的开发效率。</p>
<h4 id="多线程与多进程比较">多线程与多进程比较</h4><ol>
<li>多进程比多线程开销大；</li>
<li>多线程已经是C++标准，为线程间通信提过原生支持，更容易编写跨平台代码；</li>
<li>线程共享地址空间，需要编写更多的代码来确保数据的一致性；</li>
<li>多进程依赖与平台相关的API，却能编写出更安全的并发代码；</li>
<li>多进程能够通过网络实现分布式系统，提高并发性和性能。</li>
</ol>
<p>由于我们是讨论C++的并发，因此，主要是关注多线程并发。</p>
<h2 id="1-2_为什么使用并发？">1.2 为什么使用并发？</h2><p>使用并发的主要原因有两点：</p>
<ol>
<li>关注点分离（SOC）</li>
<li>性能</li>
</ol>
<h3 id="1-2-1_为了分离关注点">1.2.1 为了分离关注点</h3><p>分离关注点是：通过将相关代码与无关代码分离，可以是程序更易理解和测试，降低出错率。这种情况关注点是概念上的设计，使得代码更清晰。</p>
<h3 id="1-2-2_为了性能">1.2.2 为了性能</h3><p>提高并发性能的两种方式：</p>
<ol>
<li>将单一任务分成几个部分，且各自并行运行，从而降低总运行时间，称“任务并行”。根据并行的细节，还可以分为：1）过程并行——多个线程执行算法的不同部分，2）数据并行——通过对多组数据同时执行相同的操作。</li>
<li>使用并行方式，来解决更大的问题。这是数据并行的一个应用，但是关注点不一样，数据并行强调降低处理的总时间，而此方式关注点是处理使用并行处理更大的问题，甚至是串行难以完成的问题。比如处理大量数据，使用并发提高吞吐量。</li>
</ol>
<h3 id="1-2-3_什么时候不使用并发">1.2.3 什么时候不使用并发</h3><p>不是用并发的唯一原因是：收益比不上成本。</p>
<ol>
<li>除非潜在的性能增益足够大或关注点分离地足够清晰，能抵消所需的额外的开发时间以及与维护多线程代码相关的额外成本(代码正确的前提下)；否则，别用并发。</li>
<li>性能增益可能会小于预期，比如：产生线程的时间要远大于线程执行时间；</li>
<li>线程是有限的资源，如果让太多的线程同时运行，则会消耗很多操作系统资源，从而使得操作系统整体上运行得更加缓慢；</li>
<li>运行越多的线程，操作系统就需要做越多的上下文切换，每个上下文切换都需要耗费本可以花在有价值工作上的时间；</li>
</ol>
<p>为性能而使用并发就像所有其他优化策略一样:它拥有大幅度提高应用性能的潜力，但它也可能使代码复杂化，使其更难理解，并更容易出错。因此，只有应用中具有显著增益潜力的性能关键部分，才值得并发化。当然，如果性能收益的潜力仅次于设计清晰或关注点分离，可能也值得使用多线程设计。</p>
<h2 id="1-3_C++中使的并发和多线程">1.3 C++中使的并发和多线程</h2><h3 id="1-3-1_C++多线程历史">1.3.1 C++多线程历史</h3><p>从C语言的平台相关API，到C++面向对象的平台相关API，再到C++面向对象平台无关类库，最后成为C++标准。</p>
<h3 id="1-3-2_新标准支持并发">1.3.2 新标准支持并发</h3><p>所有的这些随着C++11标准的发布而改变了,不仅有了一个全新的线程感知内存模型，C++标准库也扩展了：包含了用于管理线程、保护共享数据、线程间同步操作，以及低级原子操作的各种类。</p>
<h3 id="1-3-3_C++线程库的效率">1.3.3 C++线程库的效率</h3><p>实现使用高级工具和直接低级工具的开销差称为“抽象惩罚”。</p>
<p>多线程效率在C++标准设计之初就一直考虑在内，在大部分主流平台上都能实现高效，有非常低的抽象惩罚。</p>
<p>在非常罕见的情况下，当C++标准库没有提供所需的性能或行为时，就有必要使用平台相关的工具。</p>
<h3 id="1-3-4_平台相关的工具">1.3.4 平台相关的工具</h3><p>在C++线程库中提供一个 native_handle() 成员函数，允许通过使用平台相关API直接操作底层实现。</p>
<h2 id="1-4_开始入门">1.4 开始入门</h2><h3 id="Hello,_Concurrent_World">Hello, Concurrent World</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> 		//线程库头文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> 			<span class="comment">//线程开始函数</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello Concurrent World\n"</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>; 	<span class="comment">//通过thread对象启动线程</span></span><br><span class="line">	t.join(); 				<span class="comment">//等待线程执行完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
<ol>
<li>《C++ Concurrency In Action》</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-1_何谓并发">1.1 何谓并发</h2><p>最简单和最基本的并发是指两个或更多独立的活动同时发生，在计算机领域，并发指的是在单个系统里同时执行多个独立任务。</p>
<p>计算机并发物理方式：多核并行、单核任务切换以及多核任务切换。</p>
<h3 id="1-1-2_并发的途径">1.1.2 并发的途径</h3><p>并发的两种基本途径：多进程并发和多线程并发。</p>
<h4 id="多进程并发">多进程并发</h4><p>将应用程序分为多个独立的进程，使其同时运行，进程间通过常规的通信渠道传递消息（包括信号、套接字、文件、管道等等）。</p>
<p>缺点：</p>
<ol>
<li>通信设置复杂或者通信速度慢（慢的原因是操作系统的进程安全保护措施，避免一个进程去修改另一个进程的数据）；</li>
<li>进程消耗的资源大，主要表现为启动时间长，操作系统需要消耗资源来管理进程。</li>
</ol>
<p>优点：</p>
<ol>
<li>由于操作系统为进程间提供了附加保护操作和更高级别的通信机制，从而能够更容易的编写出安全的并发代码；</li>
<li>通过网络，使用远程连接方式，在不同机器上运行独立的进程，虽然增加了通信成本，但在设计精良的系统上，这是一个提高并行可用性和性能的低成本方式。]]>
    
    </summary>
    
      <category term="C++11" scheme="http://hanhaichensha.coding.me/tags/C-11/"/>
    
      <category term="并发编程" scheme="http://hanhaichensha.coding.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://hanhaichensha.coding.me/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[别样的进制]]></title>
    <link href="http://hanhaichensha.coding.me/2016/06/06/%E5%88%AB%E6%A0%B7%E7%9A%84%E8%BF%9B%E5%88%B6/"/>
    <id>http://hanhaichensha.coding.me/2016/06/06/别样的进制/</id>
    <published>2016-06-05T16:09:05.000Z</published>
    <updated>2016-11-04T05:54:16.198Z</updated>
    <content type="html"><![CDATA[<p>在<a href="http://t.cn/R5qdeVp" target="_blank" rel="external">《别样的整数表示和运算》</a>中遗留了一个问题——进制转换问题。在进入今天的主题前，先给一个趣题让大家思考一下：</p>
<blockquote><p>老鼠与毒药升级版：有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有三星期的时间进行实验，在某轮实验中死掉的老鼠，无法继续参与之后的实验。为了从 1000 个瓶子中找出毒药，你最少需要几只老鼠？</p>
<footer><strong>知乎老鼠与毒药问题</strong><cite><a href="https://www.zhihu.com/question/19676641" target="_blank" rel="external">www.zhihu.com/question/19676641</a></cite></footer></blockquote>
<a id="more"></a>
<h3 id="1、从十进制说起">1、从十进制说起</h3><p>什么叫进制，进制又叫<a href="https://zh.wikipedia.org/wiki/进位制" target="_blank" rel="external">进位制(下面定义来自中文维基百科)</a>是一种记数方式，亦称进位计数法或位值计数法。利用这种记数法，可以使用有限种数字符号来表示所有的数值。一种进位制中可以使用的数字符号的数目称为这种进位制的基数或底数。若一个进位制的基数为n，即可称之为n进位制，简称n进制。现在最常用的进位制是十进制，这种进位制通常使用10个阿拉伯数字（即0-9）进行记数。</p>
<p>我们可以用不同的进位制来表示同一个数。比如：十进数57(10)，可以用二进制表示为111001(2)，也可以用五进制表示为212(5)，同时也可以用八进制表示为71(8)、亦可用十六进制表示为39(16)，它们所代表的数值都是一样的。</p>
<p>在10进制中有10个数字(0 - 9)，比如</p>
<embed src="http://latex.codecogs.com/svg.latex?{\displaystyle 2506=2\times 10^{3}+5\times 10^{2}+0\times 10^{1}+6\times 10^{0}} " type="image/svg+xml">

<p>在16进制中有16个数字(0–9 和 A–F)，比如</p>
<embed src="http://latex.codecogs.com/svg.latex?{\displaystyle 171B=1\times 16^{3}+7\times 16^{2}+1\times 16^{1}+B\times 16^{0}}" type="image/svg+xml">

<p>  (这里用字符B表示数字11)<br>一般说来，b进制有b个数字，如果<embed src="http://latex.codecogs.com/svg.latex? {\displaystyle a_{3},a_{2},a_{1},a_{0}}" type="image/svg+xml"> 是其中四个数字，那么就有</p>
<p><embed src="http://latex.codecogs.com/svg.latex?{\displaystyle a_{3}a_{2}a_{1}a_{0}=a_{3}\times b^{3}+a_{2}\times b^{2}+a_{1}\times b^{1}+a_{0}\times b^{0}}" type="image/svg+xml">(注意，<embed src="http://latex.codecogs.com/svg.latex?{\displaystyle a_{3}a_{2}a_{1}a_{0}}" type="image/svg+xml"> 表示一个数字序列, 而不是数字的相乘)</p>
<p>看完上面的定义，我不禁想到，所谓进位制，其实就是跟数表示与数字所在位置有关，在不同的位置上的数字代表了不同量级的大小。这与我们最开始的掰手指不同，掰手指无论你从左边掰到右边，还是从右边掰到左边，我们都是把所有手指代表的大小认为是相等的，且为1，然后用加法一个一个加起来，得到用掰手指代表的数。这就是在进位制出现之前，我们的祖先使用的计数方法，这是对数的一个初级抽象，这种例子还有很多，比如罗马人用I代表1，用V代表5，X代表10，L代表50，C代表100，D代表500，M代表1000，再往上就没了，罗马人要表示2就是用II，要表示100万的话，他们就要拼命话M了。不过罗马数字中也有一个跟位置有关的计数方法，比如：7他们就用VII（I在V右边用V+II=5+2），4用IV（I在V左边用V-I=5-1）表示或者IIII表示。</p>
<p>大家都发现了这种计数方式麻烦了，要表示一个大一点的数要写好久，而且很费纸。于是印度人发明的包括0在内的10个阿拉伯数字的阿拉伯数表示法得到了大家的青睐。这种表示法书写简单，也就是我们现在使用的10进制数。</p>
<p>说明了10进制数的来由，那现在我们深入讨论10进制的含义。10进制，只用0、1、2、3、4、5、6、7、8、9（当然，你还可以使用其它10个符号，比如a、b、c、d、e、f、g、h、i、j）这10个符号来表示所以的数，为什么是10个符号，估计多少跟我们有10根手指有关。如果只用一个符号来表示数，它只能让我们区分出10个数，如果要表示与前面不同的第11个数，我们就必须使用两字符来表示，这就是为什么说逢十进一，两个符号来表示，又有很多种情况，为了使表示有规律性，我们就规定数字位置的顺序，最右边的符号表示是用一个符号表示的那10个数，在这个符号的左边那一个符号又可以像这个符号一样表示10种情况，只不过它表示的基数是10了，这个概念就是我们所说的<strong>个十百千万位</strong>。使用这个统一的规律进行下去，我们就可以轻易的表示很大的数，而且很简单，上面定义中已经有数学抽象了，这里省略这部分。</p>
<h3 id="2、其他进制">2、其他进制</h3><p>上面已经讨论了10进制的来由和规律，那么我们考虑一下这么一种情况：假如，在外太空有一个类似人类的智能物种，他们也有两只手，每只手只有4根手指，所以他们总共只有8根手指。那么现在问题来了，他们计数系统是什么样的呢？这里有一种可能就是跟我们使用技术系统类似，他们使用8个符号来表示所有的数，比如使用如下八个符号：a、b、c、d、e、f、g、h来表示。假如在未来的某天，我们跟这个星球的外星人建立的深厚的友谊，我们可以使用我们的资源与他们的资源进行交换。有一个外星人向你买一个东西，这个东西要15块钱（假设汇率是1），这时你该向他说要多少钱呢？</p>
<p>要回答这问题，我们先来看看他们的计数系统的表示方法。与10进制类似的，只有8个符号，如果只用一个符号表示，最多能表示8个不同的数，如果要表示所有的数，必须使用多个符号，为了方便表示，引进位的概念，每一个位代表不同的量级，比如：a表示没有东西也就是数0，ba表示第九个数，由于包括0在内，所以第九个数就是我们10进制的8，由此，我们就能建立起一个类似10进制的8进制数的表示方式。抽象成数学概念就是：八进制就是用a、b、c、d、e、f、g、h不可拆分的基数通过位权（权值为8）来表示所有的数的计数方法。用公式表示就是</p>
<p><embed src="http://latex.codecogs.com/svg.latex? {\displaystyle a_{n},\dots,a_{2},a_{1},a_{0}\in\{a,b,c,d,e,f,g,h\}}" type="image/svg+xml">，</p>
<p><embed src="http://latex.codecogs.com/svg.latex?{\displaystyle a_{n}\dots a_{2}a_{1}a_{0}=a_{n}\times 8^{n}+\dots +a_{2}\times 8^{2}+a_{1}\times 8^{1}+a_{0}\times 8^{0}} " type="image/svg+xml">;</p>
<p>现在回到刚刚那个问题，问题的本质就是问如何用8进制数表示10进制数15，所谓要进行转换，最关键的点是他们表示的数量是一样的，所以我们可得到下面这个公式：</p>
<p><embed src="http://latex.codecogs.com/svg.latex?{\displaystyle a_{n}\dots a_{2}a_{1}a_{0}=a_{n}\times 8^{n}+\dots+a_{2}\times 8^{2}+a_{1}\times 8^{1}+a_{0}\times 8^{0}=x}" type="image/svg+xml">;其中x就是十进制数。</p>
<p>将公式变一下形：</p>
<p><embed src="http://latex.codecogs.com/svg.latex?{\displaystyle a_{n}\dots a_{2}a_{1}a_{0}=8\times (8\times (\dots (8\times a_{n} + a_{n-1})\dots ) + a_{1})+a_{0}=x}" type="image/svg+xml">;</p>
<p>现在我们把x除以8，由于</p>
<p><embed src="http://latex.codecogs.com/svg.latex?{\displaystyle x=8\times (8\times (\dots (8\times a_{n} + a_{n-1})\dots ) + a_{1})+a_{0}}" type="image/svg+xml">;<br>所以有：</p>
<p><embed src="http://latex.codecogs.com/svg.latex?{\displaystyle x\div 8=(8\times (8\times (\dots (8\times a_{n} + a_{n-1})\dots ) + a_{1})+a_{0})\div 8=8\times (\dots (8\times a_{n} + a_{n-1})\dots ) + a_{1}\cdots a_{0}}" type="image/svg+xml">，<br>商是：<embed src="http://latex.codecogs.com/svg.latex?{\displaystyle 8\times (\dots (8\times a_{n} + a_{n-1})\dots ) + a_{1}}" type="image/svg+xml">,<br>余数是：<embed src="http://latex.codecogs.com/svg.latex?{\displaystyle a_{0}}" type="image/svg+xml">;</p>
<p>以此类推下去，可以依次得到<embed src="http://latex.codecogs.com/svg.latex? {\displaystyle a_{0},a_{1},a_{2}\dots,a_{n}}" type="image/svg+xml">。</p>
<p>这就是为什么在很多计算机教科书中进制转换的数学原理，教科书中只说了，用十进制数除以要转换为的进制数的权值，求出商和余数，然后再用商除以权值，求出商和余数，直至商为0，最后将余数倒过来写就是我吗要转换的结果。下面示范一下：</p>
<p>1、<embed src="http://latex.codecogs.com/svg.latex? {\displaystyle 15\div 8=1\cdots 7}" type="image/svg+xml">,商是1，余数是7；<br>2、<embed src="http://latex.codecogs.com/svg.latex? {\displaystyle 1\div 8=0\cdots 1}" type="image/svg+xml">，用上次的商除以8，此次商为0，余数1<br>3、最后把求得的余数从后面最后余数向第一余数写下来：17，这就是结果，当然我们之前的协定是用a、b、c、d、e、f、g、h来表示，所以就是bh，这里不用0~7表示的原因是，这只是符号而已，不要被以前的思维定势绑架了自己，我们应该释放自己的想象力。</p>
<p>在生活中其实还有好多进制，比如12进制、24进制、60进制等等，有兴趣的小伙伴，可以自己玩玩这些进制的表示和转换。请注意了，我们这里的转换都是用10进制作为跳板进行的，如果你想从8进制直接和12进制进行转换，你可以尝试一下有没有什么规律，找到了顺便告诉我一下。</p>
<p>===========<br>2016年6月6号10时更新：<br>其他进制之间也是可以直接转换的，只要你有相应的进制的乘法表。</p>
<p>===========</p>
<h3 id="3、回答老鼠和毒药问题">3、回答老鼠和毒药问题</h3><p>老鼠与毒药升级版：有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有三星期的时间进行实验，在某轮实验中死掉的老鼠，无法继续参与之后的实验。为了从 1000 个瓶子中找出毒药，你最少需要几只老鼠？</p>
<p>如果我们使用某种进制的数对这1000平液体进行编码，每一次实验都可以用一只老鼠来负责某一位的某个符号的检测，如果老鼠不幸牺牲了，说明这一位就是这个符号，这一位不需要进行下面的的实验了，如果老鼠没事，那让老鼠再接再厉，继续对这一位进行检查。最后就能确定是哪个数，也就能找到对应的瓶子，那问题就转变成了，用什么进制进行编码，最大数（这里是1000）在这种编码下一共要多少位字符表示，就要多少只老鼠。</p>
<p>由于只有三个星期的时间，只能做3此次实验。也就是说每一位都只有3中情况，很容易就想到了用三进制来对1~1000进行编码，如下：</p>
<img src="/blog/2016/06/06/别样的进制/图一.png" alt="图一" title="图一">
<p>1、第一周，让这七只都喝相应位为0的瓶子中的液体，比如：老鼠1喝1~6等，老鼠7喝3，……，996，999，如图，用红线圈起来的。</p>
<img src="/blog/2016/06/06/别样的进制/图二.png" alt="图二" title="图二">
<p>2、一周后，如果老鼠1牺牲了，那么可以确定有毒那瓶的编码最高位是0，那么这个编号就是0xxxxxx。那么接下来，让剩下的6只老鼠依旧喝之前负责的那一位上符号为1的液体，比如：老鼠2喝995~1000等，如图，用红线圈起来的。</p>
<img src="/blog/2016/06/06/别样的进制/图三.png" alt="图三" title="图三">
<p>3、两周后，如果老鼠4牺牲了，那么可以确定有毒那瓶的编码从右边数第四位是1，那么这个编号就是0xx1xxx。那么接下来，让剩下的5只老鼠依旧喝之前负责的那一位上符号为2的液体，比如：老鼠5喝995~998等，如图，用红线圈起来的。</p>
<img src="/blog/2016/06/06/别样的进制/图四.png" alt="图四" title="图四">
<p>4、三周后，老鼠2、3、5、6、7应该都会牺牲，那么可以确定有毒那瓶的编码的2、3、5、6、7位是2，那么这个编号就是0221222，也就是701号那瓶是有毒液体，为什么呢？因为，通过前两周的实验，我们已经排除了有毒液体编号在2、3、5、6、7位上是0和1的可能性，否则，老鼠2、3、5、6、7在前两次实验中就应该牺牲了。所以第三周的实验是浪费掉的，还把所有老鼠害死了。</p>
<p>所以，我们可以设计的方案是有问题的，进行三次实验，其实要用四进制来表示1~1000这些数，这样我们只需要使用5只老鼠，具体步骤不详写了，有兴趣的小伙伴可以自己去推演一遍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="http://t.cn/R5qdeVp">《别样的整数表示和运算》</a>中遗留了一个问题——进制转换问题。在进入今天的主题前，先给一个趣题让大家思考一下：</p>
<blockquote><p>老鼠与毒药升级版：有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有三星期的时间进行实验，在某轮实验中死掉的老鼠，无法继续参与之后的实验。为了从 1000 个瓶子中找出毒药，你最少需要几只老鼠？</p>
<footer><strong>知乎老鼠与毒药问题</strong><cite><a href="https://www.zhihu.com/question/19676641">www.zhihu.com/question/19676641</a></cite></footer></blockquote>]]>
    
    </summary>
    
      <category term="数学" scheme="http://hanhaichensha.coding.me/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="计算机基础" scheme="http://hanhaichensha.coding.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机基础" scheme="http://hanhaichensha.coding.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[别样的整数表示和运算]]></title>
    <link href="http://hanhaichensha.coding.me/2016/06/04/%E5%88%AB%E6%A0%B7%E7%9A%84%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/"/>
    <id>http://hanhaichensha.coding.me/2016/06/04/别样的整数表示和运算/</id>
    <published>2016-06-04T15:47:02.000Z</published>
    <updated>2016-11-04T05:54:16.195Z</updated>
    <content type="html"><![CDATA[<p>最近进入懒癌晚期，拖延症重症期，总惦记着让自己写点东西，然而回头一看，已经将近两个月没写东西，看书也开始打瞌睡，彻底进入老年人模式。细思极恐，鼓起勇气，把最近吹着电扇，抠着脚丫看的些东西记录一下。此文涉及的知识非常简单，主要是涉及小学整数加减运算。</p>
<p>主要是温习一下计算机基础知识，计算机的信息表示和处理基础二进制整数的表示和运算。不过，我不打算照着书本介绍一下二进制，今天我们使用我们熟知的十进制（也就是我们平时使用的数）来介绍其中的原理。这样做的好处有很多：1、对于不熟悉二进制的或者说不熟悉进制的读者也可以理解一二，而不用多费口舌去介绍进制的概念；2、使用十进制，可以让自己对书本上的原理有更好的理解；3、使用十进制，可以让自己增进对知识的迁移能力，已达到触类旁通等等。</p>
<h3 id="1、小学一年级加法（十以内加法）">1、小学一年级加法（十以内加法）</h3><p>请注意了，各位童鞋，请用掰手指的方法告诉下面这道题加法题的答案</p>
<p><strong>题目1：3+5=？</strong></p>
<p>有八根手指对吧。再来</p>
<p><strong>题目2：6+7=？</strong></p>
<p>多少？13？你确定你是13吗？请问你真的有13根手指吗？反正我是只看到了3根手指，我的答案是3。这不禁让人感叹人生苦短，在有限的时间范围之内，你想得到的越多，反而拥有的会越少。一不小心又变成了鸡汤小短文，寓言小故事。<br><a id="more"></a></p>
<h3 id="2、小学二年级加减法（一百以内加减法）">2、小学二年级加减法（一百以内加减法）</h3><p>一年级的太简单了，我们快速进入二年级，请听题：</p>
<p><strong>题目3：28+57=？</strong></p>
<p>答案是……，我还没算出来，容我开个挂，用计算器算一下，答案是85，各位小盘友，使用一百根火柴棒就能算出来哦(<em>^__^</em>)。接着看题：</p>
<p><strong>题目4：68+57=？</strong></p>
<p>请注意了，你只有一百根火柴棒，这次你应该能给出正确答案，答案是：25。到目前为止，你已经学会了加法了，下面来学习减法：</p>
<p><strong>题目5：68-43=？</strong></p>
<p>不啰嗦了，直接给答案：25。来一道有难度的减法：</p>
<p><strong>题目6：28-57=？</strong></p>
<p>以我小学二年级的智商，表示不知道答案。那让我们进入到高年级阶段。</p>
<h3 id="3、高年级阶段（部分涉及超越了小学知识）">3、高年级阶段（部分涉及超越了小学知识）</h3><p>所谓高年级就是知道了负数这么一个概念，所以题目6的答案就是-29。既然进入了高年级，那我们来做另外一件有意思的事，把减法变成加法，省的记两种运算规则。我们来仔细看一下题目4和题目5，<br><strong>题目4：68+57=？</strong><br><strong>题目5：68-43=？</strong></p>
<p>这两道题根据<strong>有限范围内</strong>的加减法得出的结果是一样的，都是25，那我们是不是可以将题目5的减法变成题目4的加法呢？进一步，在<strong>有限范围内</strong>的加减法，是不是所有的减法都可以转变成加法，使用加法规则做减法运算呢？答案是肯定的，下面我们就来实现这一猜想。</p>
<p>我们都知道，一个数减去一个数等于一个数加上一个负数，现在的问题是怎么把这个负数表示成一个正数。你有没有发现，题目4和题目5中的第二运算数57和43的关系，这两个数加起来57+43=100，正好是我们所规定的范围（一百以内的加减法），当然，如果按照一百以内不含一百的加法计算，这个结果应该是0。找到这个规律，我们来看是不是真的是这样呢？再来验证一下，73-27=73+73=46（请注意这都是都是100以内的计算）。好像是对的，为什么呢？因为100以内的加法，超过100（包括100）的数都要减去100，也就是：73-27=73+(73-100)=73+73-100，此时73+73-100正好是表达100以内的加法运算。好像有什么不对，谁能保证所有的运算都能像73+73-100这样，前两个数的和大于100呢，有没可能小于100呢？那肯定是有可能的，就拿这个例子来说，假设第一个数为x，要x+73<100，也就是x<100-73=27，也就是说x-27是一个负数，同时x+73-100也正好是一个负数，也说明这个两个数是相等的，但它还是用负数表示。综上，当y>0，x-y可以表示成x-y+100，也就是说-y用正数表示是100-y。</100，也就是x<100-73=27，也就是说x-27是一个负数，同时x+73-100也正好是一个负数，也说明这个两个数是相等的，但它还是用负数表示。综上，当y></p>
<h3 id="3、正规化阶段">3、正规化阶段</h3><p>经过前面一些简单的介绍，让我们来总结和归纳一下这个<strong>在一定范围内</strong>的加减法运算。</p>
<h4 id="1、让数的表示更正规化">1、让数的表示更正规化</h4><p>上面提到过正数和负数的表示，以及如何将一个减法变成一个加法，然和将负数变成一个正数进行相加，且等到与加法相等的结果。现在我们将其进行更进一步的整理。</p>
<p>表示一个一百以内的十进制数（不包括100，当然这里所说的数是指|x|&lt;100的数），我们只需要两个数字进行组合即可得到，考虑到有正与负数，我们多加一位表示正负，这一位可以是+、-，比如+20、-60等。我也说过了，我现在是懒癌晚期，我只想学习正数加法，我天真的把所有数都变成正数，而且只是数，连正负号都是用数字，还能表示出这个数是正数还是负数，所以绝对值在100以内的数，只需要三位数表示，而且我们只用三个数表示。明确了目标，那开始吧：</p>
<p>100以内的正数表示：最高位用0或1表示这是一个正数，后两位表示数的大小。比如：+20表示成020。<br>绝对值100以内的负数的表示：最高位用8或9表示是负数，一般使用9，后两位表示数的大小，当然了为了能让负数变成正数加法，数的大小部分还是用100-数的大小部分。比如：-60表示成940（9是符号位，40=100-60）。</p>
<h4 id="2、让计算方法更正规化">2、让计算方法更正规化</h4><p>将数的表示正规化后，我们用正规化后的数带入之前的题目中进行计算，注意符号位也当作数值进行运算，且只能保留最低三位数，看看能不能得到正确答案：</p>
<p><strong>题目3：28+57=028+057=085</strong><br><strong>题目4：68+57=068+057=125=025     (前面说过，0或1都表示正数，通常我们会把1变成0来表示)</strong><br><strong>题目5：68-43=068+957=1025（超过了3个位，把最高为丢掉）=025</strong><br><strong>题目6：28-57=028+943=971</strong><br><strong>题目7：-66-88=934+912=1846（超过了3位，把最高位丢掉）=846=946(前面说过，8或9都表示负数，通常我们会把8变成9来表示)</strong></p>
<p>题目3、4、5的结果都是正数，且结果和我们之前得到是一样的，题目6、7的结果是负数，题6值为100-71=29，所以结果是-29，也与我之前的结果一致，题7的值为-54，也是正确值。至此，我们就实现了绝对值在100以内的正负数加减法的正规化，全部简化为加法运算。</p>
<p>至此，可以结束本文了，不过，我们现在不禁要问，为什么我们这样做可以得到与我们以前计算方法一致的结果呢？</p>
<p>嗯，这个超出了小学数学知识的范畴了，我们之所以可以等到相同的结果，因为我们讨论的<strong>在一定范围内</strong>的带符号加法运算和<strong>在一定范围内</strong>的不带符号的加法运算都是一个阿贝尔群，还具有相同的单位元，而且表示的范围是符合双射关系。简单点说，我们现在讨论的整数加法是一个<a href="https://zh.wikipedia.org/wiki/阿贝尔群" target="_blank" rel="external">阿贝尔群</a>，满足（下面是个人的通俗说法，准确定义请参考相关专业书籍）：<br>1、封闭性：通俗说就是加数与和属于同样的一个取值域，比如绝对值100以内的加法运算，如果大于等于100我们就减去100，得到的和还是在100以内，转换成不带正负号的加法，就是计算[0,999]内的正整数加法，加数与和都是在[0,999]区间；<br>2、结合律：就是满足结合律，a+b+c=(a+b)+c=a+(b+c)，a、b、c是任意取值域的值;<br>3、单位元：就是满足，a+e=a，e+a=a，a是任意取值域的值，e就是单位元,这里两种情况的单位元都是0；<br>4、逆元：对取值域中的任意a，取值域中都存在b，使得a+b=单位元，b称为a的逆元。比如：绝对值100以内的加法运算，x的逆元就是-x，而在[0,999]无符号加法的x的逆元就是1000-x；<br>5、交换律：对取值域中的任意a、b，都有a+b=b+a。</p>
<p>这就是原因，估计很多小伙伴根本看不懂，只能说就当热闹看看，不要求弄懂。</p>
<h3 id="4、衍生阶段">4、衍生阶段</h3><p>说了这么久，说好的计算机基础呢？为什么与计算机没半毛钱关系，鉴于此，我就简单说一下，计算机使用的是二进制，加法分为有符号和无符号整数加法。有符号的计算使用了类似上面的方法，正数最高位是0，负数最高位是1，后面的位表示值。</p>
<p>用一个例子说明一下：<br>用4位二进制表示一个数，最高位是符号位，还有3位用于表示数值，所以二进制数的取值范围是[-8,7],</p>
<p><strong>题目8：2-4=0010+1100=1110=-2</strong></p>
<p>最后强调一下，有些小伙伴说，一个数的补码很难求，其实，在二进制中的补码其实就是上面说的逆元，只要你理解了上面逆元的概念，是很好求的，比如十进制中减掉一个数，其实就是加上这个数的逆元。<br>举几个例子熟练一下（用4位数表示，最高位是符号位），算法就是：x逆元=10……0-x（10……0总共有指定数的表示位数个0，用4位数表示，因此这里是4）：<br>-1=1的逆元=10000-1=9999<br>1=-1的逆元=10000-(-1)=10000+1=0001<br>-48=48的逆元=10000-48=9952</p>
<p>下面是一个二进制的例子：<br>-4=0100的逆元=10000-0100=1100</p>
<p>下面是一些计算中的补码（即逆元）的应用：<br>20-48=0020+(10000-48)=0020+9952=9972=-28，同样的在二进制中，2-4=0010+(10000-0100)=0010+1100=1110=-2</p>
<p>当然如果你学过计算机相关知识，还有一种求补码（逆元）的方法，原码（原数）取反加一即得补码（逆元），其中原码取反得到的数被成为反码。取反就是：指定的位数中的最大数-原码，什么意思？举个例子，用四位数表示下面的数的反码，由于是用四位数表示，所以四位数最大能表示的数是9999：<br>48的反码=9999-48=9951<br>根据：补码=反码+1得：<br>48的补码=48的反码+1=9951+1=9952=-48<br>同理，用二进制表示下面的数，四位最大二进制数能表示的最大数是1111：<br>4的反码=1111-0100=1011<br>4的补码=4的反码+1=1011+1=1100=-4</p>
<h3 id="小结">小结</h3><p>在<strong>有限范围内</strong>的整数计算中，将负数使用补码（也就是逆元）参与运算，就能只使用加法实现有符号整数的加减法运算，这其中使用到的就是群的性质，尤其是逆元公式：x+y=e。在有符号整数计算中x+(-x)=0，而无符号整数计算有：x+(x的逆元)=0，所以我们将无符号整数中的逆元等效于有符号整数中的负数，以此达到只使用加法实现加减法运算的目的。本文还有一点没写清楚，那就是进制转换，后面几个例子中涉及十进制转二进制，等有时间再写。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近进入懒癌晚期，拖延症重症期，总惦记着让自己写点东西，然而回头一看，已经将近两个月没写东西，看书也开始打瞌睡，彻底进入老年人模式。细思极恐，鼓起勇气，把最近吹着电扇，抠着脚丫看的些东西记录一下。此文涉及的知识非常简单，主要是涉及小学整数加减运算。</p>
<p>主要是温习一下计算机基础知识，计算机的信息表示和处理基础二进制整数的表示和运算。不过，我不打算照着书本介绍一下二进制，今天我们使用我们熟知的十进制（也就是我们平时使用的数）来介绍其中的原理。这样做的好处有很多：1、对于不熟悉二进制的或者说不熟悉进制的读者也可以理解一二，而不用多费口舌去介绍进制的概念；2、使用十进制，可以让自己对书本上的原理有更好的理解；3、使用十进制，可以让自己增进对知识的迁移能力，已达到触类旁通等等。</p>
<h3 id="1、小学一年级加法（十以内加法）">1、小学一年级加法（十以内加法）</h3><p>请注意了，各位童鞋，请用掰手指的方法告诉下面这道题加法题的答案</p>
<p><strong>题目1：3+5=？</strong></p>
<p>有八根手指对吧。再来</p>
<p><strong>题目2：6+7=？</strong></p>
<p>多少？13？你确定你是13吗？请问你真的有13根手指吗？反正我是只看到了3根手指，我的答案是3。这不禁让人感叹人生苦短，在有限的时间范围之内，你想得到的越多，反而拥有的会越少。一不小心又变成了鸡汤小短文，寓言小故事。<br>]]>
    
    </summary>
    
      <category term="数学" scheme="http://hanhaichensha.coding.me/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="计算机基础" scheme="http://hanhaichensha.coding.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机基础" scheme="http://hanhaichensha.coding.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初识Netfilter/iptables]]></title>
    <link href="http://hanhaichensha.coding.me/2016/03/25/%E5%88%9D%E8%AF%86Netfilter-iptables/"/>
    <id>http://hanhaichensha.coding.me/2016/03/25/初识Netfilter-iptables/</id>
    <published>2016-03-25T12:49:54.000Z</published>
    <updated>2016-11-04T05:54:16.156Z</updated>
    <content type="html"><![CDATA[<h3 id="一、什么是Netfilter/iptables？">一、什么是Netfilter/iptables？</h3><blockquote><p>iptables是一个运行在用户空间的应用软件，通过控制Linux内核netfilter模块，来管理网络数据包的流动与转送。在大部分的Linux系统上面，iptables是使用/usr/sbin/iptables来操作，文件则放置在手册页底下，可以通过 man iptables 指令获取。通常iptables都需要内核层级的模块来配合运作，Xtables是主要在内核层级里面iptables API运作功能的模块。因相关动作上的需要，iptables的操作需要用到超级用户的权限。</p>
<p>目前iptables系在2.4、2.6及3.0的内核底下运作，旧版的Linux内核（2.2）使用ipchains及ipwadm（Linux 2.0）来达成类似的功能，2014年1月19日起发行的新版Linux内核（3.13后）则使用nftables取而代之。</p>
<footer><strong>维基百科</strong><cite><a href="https://zh.wikipedia.org/wiki/Iptables" target="_blank" rel="external">zh.wikipedia.org/wiki/Iptables</a></cite></footer></blockquote>
<a id="more"></a>
<p>以上就是中文维基百科上给出的定义，看完后，仍然不知所云，iptables的功能具体是什么？它与NetFilter是什么关系？</p>
<p>iptables是用来管理网络数据包的流动和转送的，也就是控制数据包的流向。我们都知道网络数据包在流经一台电脑时，数据包一般只有两种流向，一是目的地址是本机的：网卡驱动接收数据包-&gt;路由程序处理-&gt;本地协议栈处理-&gt;网卡驱动发送数据包；另一种流向是目的地址不是本机：网卡驱动接收数据包-&gt;路由程序处理数据包-&gt;将数据包转送到另一网卡-&gt;网卡驱动发送数据包。为了能灵活的管理数据包，Linux内核使用Netfilter模块在这些主要流向的路径的关键位置添加了一些钩子。如下图：</p>
<img src="/blog/2016/03/25/初识Netfilter-iptables/Netfilter-packet-flow.png" alt="Netfilter-packet-flow" title="Netfilter-packet-flow">
<p>上图过于复杂，为了便于理解，使用下面简化版的流程：</p>
<img src="/blog/2016/03/25/初识Netfilter-iptables/iptables数据包流程.png" alt="iptables数据包流程" title="iptables数据包流程">
<p>从上图可知，Netfilter在几个固定的位置设置了5个钩子：</p>
<ol>
<li>NF_INET_PRE_ROUTING:在网卡接收到数据包后，进入路由选择之前；</li>
<li>NF_INET_LOCAL_IN:在路由判断目的地址是本机之后，交给本地协议栈处理之前；</li>
<li>NF_INET_FORWARD:在路由判断目的地址不是本机之后，交给另一个网卡发送之前；</li>
<li>NF_INET_LOCAL_OUT:在本地协议栈和应用程序处理之后，交给网卡发送之前；</li>
<li>NF_INET_POST_ROUTING:在交给网卡发送之前，这是数据流中的最后一个钩子。</li>
</ol>
<p>既然有钩子，就可以定义与之对应的处理函数，这些函数也已经在Netfilter中定义好，并且与钩子绑定了。感觉所有的活，Netfilter都已经做好了，还有iptables什么事呢？</p>
<p>其实不然，先来看看Netfilter的四个基本模块：</p>
<ol>
<li>conntrack模块：连接追踪模块</li>
<li>Filter模块：过滤模块</li>
<li>Nat模块：地址转换模块</li>
<li>Mangle模块：数据包修改模块<br>其中conntrack模块是基础核心模块，而其他几个模块是在此模块的基础上，维护一张全局表，以实现各模块相应的功能。为了灵活的管理数据包，iptables就可以调用Netfilter提供的接口想这些全局表中添加相应的控制条件和处理。以此，Netfilter其实就是提供一组系统调用以实现管理网络数据包流动和转送的框架。</li>
</ol>
<p>而iptables则是提供命令处理的用户空间应用程序，同时提供了一些扩展模块以加载到内核对数据包进行处理。Netfilter和iptables的关系如图：</p>
<img src="/blog/2016/03/25/初识Netfilter-iptables/Netfilter与iptabales关系.png" alt="Netfilter与iptabales关系" title="Netfilter与iptabales关系">
<p>为了方便处理用户命令的一组有序控制策略，iptables使用table、chain、rule来表示一条策略。其中table与Netfilter中的各模块中维护的全局表进行对应，chain与挂载点（即钩子）相对应，rule处理规则。iptables策略组成如图：</p>
<img src="/blog/2016/03/25/初识Netfilter-iptables/iptables策略组成.png" alt="iptables策略组成" title="iptables策略组成">
<h3 id="二、_iptables命令格式">二、 iptables命令格式</h3><p>iptables命令语法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t 表名] 命令 [条件匹配] [目标]</span><br></pre></td></tr></table></figure></p>
<p>下面是更加详细的命令格式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables [ -t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作或跳转]</span><br></pre></td></tr></table></figure></p>
<h4 id="1-表名">1.表名</h4><p>有四张表：filter(默认值)、NAT、mangle、raw。</p>
<h4 id="2-命令选项">2.命令选项</h4><table>
<thead>
<tr>
<th style="text-align:center">选项名</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-A</td>
<td>在指定链的末尾添加（–append）一条新的规则</td>
</tr>
<tr>
<td style="text-align:center">-D</td>
<td>删除（–delete）指定链中的某一条规则，按规则序号或内容确定要删除的规则</td>
</tr>
<tr>
<td style="text-align:center">-I</td>
<td>在指定链中插入（–insert）一条新的规则，默认在链的开头插入</td>
</tr>
<tr>
<td style="text-align:center">-R</td>
<td>修改、替换（–replace）指定链中的一条规则，按规则序号或内容确定</td>
</tr>
<tr>
<td style="text-align:center">-L</td>
<td>列出（–list）指定链中的所有的规则进行查看，默认列出表中所有链的内容</td>
</tr>
<tr>
<td style="text-align:center">-F</td>
<td>清空（–flush）指定链中的所有规则，默认清空表中所有链的内容</td>
</tr>
<tr>
<td style="text-align:center">-N</td>
<td>新建（–new-chain）一条用户自己定义的规则链</td>
</tr>
<tr>
<td style="text-align:center">-X</td>
<td>删除指定表中用户自定义的规则链（–delete-chain）</td>
</tr>
<tr>
<td style="text-align:center">-P</td>
<td>设置指定链的默认策略（–policy）</td>
</tr>
<tr>
<td style="text-align:center">-n</td>
<td>用数字形式（–numeric）显示输出结果，若显示主机的 IP地址而不是主机名</td>
</tr>
<tr>
<td style="text-align:center">-P</td>
<td>设置指定链的默认策略（–policy）</td>
</tr>
<tr>
<td style="text-align:center">-v</td>
<td>查看规则列表时显示详细（–verbose）的信息</td>
</tr>
<tr>
<td style="text-align:center">-V</td>
<td>查看iptables命令工具的版本（–Version）信息</td>
</tr>
<tr>
<td style="text-align:center">-h</td>
<td>查看命令帮助信息（–help）</td>
</tr>
<tr>
<td style="text-align:center">–line-number</td>
<td>查看规则列表时，同时显示规则在链中的顺序号</td>
</tr>
</tbody>
</table>
<h4 id="3-链名">3.链名</h4><p>通过之前分析，主要有一下五条链：</p>
<ol>
<li>PREROUTING：与NF_INET_PRE_ROUTING钩子相对应，此链的处理时机也与NF_INET_PRE_ROUTING的时机相对应。</li>
<li>INPUT：与NF_INET_LOCAL_IN钩子相对应，此链的处理时机也与NF_INET_LOCAL_IN的时机相对应。</li>
<li>FORWARD：与NF_INET_LOCAL_OUT钩子相对应，此链的处理时机也与NF_INET_LOCAL_OUT的时机相对应。</li>
<li>OUTPUT：与NF_INET_LOCAL_OUT钩子相对应，此链的处理时机也与NF_INET_LOCAL_OUT的时机相对应。</li>
<li>POSTROUTING：与NF_INET_POST_ROUTING钩子相对应，此链的处理时机也与NF_INET_POST_ROUTING的时机相对应。</li>
</ol>
<h4 id="4-匹配条件">4.匹配条件</h4><h5 id="1）通用匹配">1）通用匹配</h5><table>
<thead>
<tr>
<th style="text-align:center">匹配参数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-p</td>
<td>指定规则协议，如tcp, udp,icmp等，可以使用all来指定所有协议</td>
</tr>
<tr>
<td style="text-align:center">-s</td>
<td>指定数据包的源地址参数，可以使IP地址、网络地址、主机名</td>
</tr>
<tr>
<td style="text-align:center">-d</td>
<td>指定目的地址</td>
</tr>
<tr>
<td style="text-align:center">-i</td>
<td>输入接口</td>
</tr>
<tr>
<td style="text-align:center">-o</td>
<td>输出接口</td>
</tr>
</tbody>
</table>
<h5 id="2）隐含匹配">2）隐含匹配</h5><img src="/blog/2016/03/25/初识Netfilter-iptables/隐含匹配.jpg" alt="隐含匹配" title="隐含匹配">
<h5 id="3）显式匹配">3）显式匹配</h5><img src="/blog/2016/03/25/初识Netfilter-iptables/显式匹配.jpg" alt="显式匹配" title="显式匹配">
<h4 id="5-目标动作或跳转">5.目标动作或跳转</h4><table>
<thead>
<tr>
<th style="text-align:center">目标项</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ACCEPT</td>
<td>当信息包与具有ACCEPT目标的规则完全匹配时，会被接受（允许它前往目的地）</td>
</tr>
<tr>
<td style="text-align:center">DROP</td>
<td>当信息包与具有DROP目标的规则完全匹配时，会阻塞该信息包，并且不对它做进一步处理。该目标被指定为-j DROP</td>
</tr>
<tr>
<td style="text-align:center">REJECT</td>
<td>该目标的工作方式与DROP目标相同，但它比DROP好。和DROP不同，REJECT不会在服务器和客户机上留下死套接字。另外，REJECT将错误消息发回给信息包的发送方。该目标被指定为-j REJECT</td>
</tr>
<tr>
<td style="text-align:center">RETURN</td>
<td>在规则中设置的RETURN目标让与该规则匹配的信息包停止遍历包含该规则的链。如果链是如INPUT之类的主链，则使用该链的默认策略处理信息包。它被指定为-jump RETURN</td>
</tr>
<tr>
<td style="text-align:center">LOG</td>
<td>表示将包的有关信息记录入日志</td>
</tr>
<tr>
<td style="text-align:center">TOS</td>
<td>表示改写数据包的TOS值</td>
</tr>
</tbody>
</table>
<h3 id="三、_iptables应用">三、  iptables应用</h3><ol>
<li><p>删除iptables现有规则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables –F</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看iptables规则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables –L (iptables –L –v -n)</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加一条规则到最后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp --dport <span class="number">80</span> -m state --state NEW,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加一条规则到指定位置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT <span class="number">2</span> -i eth0 -p tcp --dport <span class="number">80</span> -m state --state NEW,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除一条规则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptabels -D INPUT <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改一条规则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -R INPUT <span class="number">3</span> -i eth0 -p tcp --dport <span class="number">80</span> -m state --state NEW,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置默认策略</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="四、实战——使用iptables的源地址转发功能">四、实战——使用iptables的源地址转发功能</h3><p>上面就是一些简单的介绍，下面模拟内网通过网关访问外网的一个简单例子来看看iptables的应用。</p>
<h4 id="1-准备：">1.准备：</h4><ol>
<li>用虚拟机开启两台机器，分别命名为VM1（Virtual Machine 1）和VM2，VM2当作局域网内的机器，VM2当作网关，真实机器（即本机）LM（Local Machine）当作外网；</li>
<li>现在分别为VM1配置网络，ip地址是192.186.10.1，掩码是255.255.255.0；VM2配置两网卡，网络配置分别为：网卡1：ip地址是192.168.10.2，掩码是255.255.255.0，网卡2：ip地址是10.126.72.203，掩码是255.255.255.0；LM的网络配置是：ip地址是10.126.72.23，掩码是255.255.255.0。</li>
<li>在LM上搭建一个web服务器，配置网址www.LM.com。</li>
</ol>
<p>注意：怎么配置两台虚拟机在同一个局域网内，以及如何配置本机和虚拟机在同一网络中并相互访问呢？</p>
<p>这里备注一下：下面的配置均是以VirtualBox为例。</p>
<ol>
<li>配置虚拟机局域网</li>
</ol>
<img src="/blog/2016/03/25/初识Netfilter-iptables/虚拟机网络配置1.png" alt="虚拟机网络配置1" title="虚拟机网络配置1">
<img src="/blog/2016/03/25/初识Netfilter-iptables/虚拟机网络配置2.png" alt="虚拟机网络配置2" title="虚拟机网络配置2">
<ol>
<li>配置本机和虚拟机在同一网络中并相互访问<img src="/blog/2016/03/25/初识Netfilter-iptables/虚拟机网络配置3.png" alt="虚拟机网络配置3" title="虚拟机网络配置3">
</li>
</ol>
<p>准备工作基本完成，如果顺利的话，最后将得到如下网络：</p>
<img src="/blog/2016/03/25/初识Netfilter-iptables/模拟网络.png" alt="模拟网络" title="模拟网络">
<h4 id="2-实现VM1通过VM2访问LM">2.实现VM1通过VM2访问LM</h4><p>由于LM的Web服务(www.lm.com)是本地服务并没有申请域名，还需要手动在VM1和VM2主机的/etc/hosts中添加如下一语句，否则无法对其进行域名解析：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.126</span>.<span class="number">72.23</span>     www.lm.com</span><br></pre></td></tr></table></figure>
<p>毋庸置疑，开始VM1无法访问LM的Web服务（www.lm.com）。</p>
<img src="/blog/2016/03/25/初识Netfilter-iptables/访问LM服务1.png" alt="访问LM服务1" title="访问LM服务1">
<p>下面将实现此访问。</p>
<ol>
<li><p>首先开启内核转发的模块<br>向/etc/sysctl.conf文件添加或这修改net.ipv4.ip_forward的值为1（即net.ipv4.ip_forward = 1）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置VM1的默认网关为VM2，即192.168.10.2，</p>
</li>
</ol>
<img src="/blog/2016/03/25/初识Netfilter-iptables/设置默认网关.png" alt="设置默认网关" title="设置默认网关">
<ol>
<li><p>在VM2上安装iptables及服务（此处系统为CentOS 7），并启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install iptables</span><br><span class="line">sudo yum -y install iptables-services</span><br><span class="line">sudo systemctl start iptables.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置iptables策略</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -F</span><br><span class="line">sudo iptalbes -t nat -F</span><br><span class="line">sudo iptables -t nat -A POSTROUTING <span class="operator">-s</span> <span class="number">192.168</span>.<span class="number">10.1</span>/<span class="number">32</span> -j SNAT --to <span class="number">10.126</span>.<span class="number">72.203</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这就可以实现VM1访问LM上的服务了。</p>
<img src="/blog/2016/03/25/初识Netfilter-iptables/访问LM服务2.png" alt="访问LM服务2" title="访问LM服务2">
<h3 id="五、小结">五、小结</h3><p>以上简单的介绍了iptable的基本概念和基本命令，以及命令的简单使用。这只是冰山一角，iptables还能实现如下功能：</p>
<ol>
<li>建立一个基于有状态和无状态的包过滤规则的因特网防火墙。</li>
<li>部署高度可用的有状态和无状态防火墙集群。</li>
<li>当公网ip不够用时，可以进行ip伪装，属于NAT模块。</li>
<li>使用NAT来实现透明代理。</li>
<li>辅助内核网络模块中的tc和iproute2去构造一个复杂的QoS和路由策略。</li>
<li>做进一步处理比如比如更改IP包头中的TOS/DSCP/ECN参数。</li>
</ol>
<h3 id="参考文章">参考文章</h3><p><a href="http://drops.wooyun.org/tips/1424" target="_blank" rel="external">Iptables入门教程</a><br><a href="http://blog.chinaunix.net/uid-20786208-id-3429074.html" target="_blank" rel="external">Netfilter—框架的设计</a><br><a href="http://seanlook.com/2014/02/23/iptables-understand/" target="_blank" rel="external">iptables防火墙原理详解</a><br><a href="http://blog.jobbole.com/?s=iptables%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90" target="_blank" rel="external">iptables深入解析</a><br><a href="http://blog.csdn.net/ljy1988123/article/details/50458044?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">Linux内核工程导论——网络：Netfilter概览</a><br><a href="http://vinllen.com/netfilteriptableskuang-jia-zong-jie/" target="_blank" rel="external">Netfilter/iptables框架总结</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、什么是Netfilter/iptables？">一、什么是Netfilter/iptables？</h3><blockquote><p>iptables是一个运行在用户空间的应用软件，通过控制Linux内核netfilter模块，来管理网络数据包的流动与转送。在大部分的Linux系统上面，iptables是使用/usr/sbin/iptables来操作，文件则放置在手册页底下，可以通过 man iptables 指令获取。通常iptables都需要内核层级的模块来配合运作，Xtables是主要在内核层级里面iptables API运作功能的模块。因相关动作上的需要，iptables的操作需要用到超级用户的权限。</p>
<p>目前iptables系在2.4、2.6及3.0的内核底下运作，旧版的Linux内核（2.2）使用ipchains及ipwadm（Linux 2.0）来达成类似的功能，2014年1月19日起发行的新版Linux内核（3.13后）则使用nftables取而代之。</p>
<footer><strong>维基百科</strong><cite><a href="https://zh.wikipedia.org/wiki/Iptables">zh.wikipedia.org/wiki/Iptables</a></cite></footer></blockquote>]]>
    
    </summary>
    
      <category term="Netfilter" scheme="http://hanhaichensha.coding.me/tags/Netfilter/"/>
    
      <category term="iptables" scheme="http://hanhaichensha.coding.me/tags/iptables/"/>
    
      <category term="网络" scheme="http://hanhaichensha.coding.me/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="防火墙" scheme="http://hanhaichensha.coding.me/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
      <category term="Linux防火墙" scheme="http://hanhaichensha.coding.me/categories/Linux%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单击微信文章进入原文的方法]]></title>
    <link href="http://hanhaichensha.coding.me/2016/03/06/%E5%8D%95%E5%87%BB%E5%BE%AE%E4%BF%A1%E6%96%87%E7%AB%A0%E8%BF%9B%E5%85%A5%E5%8E%9F%E6%96%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://hanhaichensha.coding.me/2016/03/06/单击微信文章进入原文的方法/</id>
    <published>2016-03-06T06:05:55.000Z</published>
    <updated>2016-11-04T05:54:16.213Z</updated>
    <content type="html"><![CDATA[<p>昨天，一朋友因为我去年帮了她一点小忙而请吃了一顿豪华早茶，表示受之有愧，想想还是将这个方法分享一下。</p>
<p>需求：当公众号向订阅用户推送一篇文章后，用户单击文章直接进入文章的原文，而不是进入微信的一个页面，然后再单击阅读原文才能进入到原文的页面，（这样对于一个有动画效果的H5页面，直接进入原文，可以直接看到动画效果，否则，有些用户点开后进入到微信的一个页面，没有单击阅读原文，从而不会看到动画效果，而且大部分用户都不会点击阅读原文）。如图：</p>
<hr>
<h4 id="正常的流程：">正常的流程：</h4><p>第一步：点击阅读原文</p>
<img src="/blog/2016/03/06/单击微信文章进入原文的方法/图一.png" alt="图一" title="图一"> 
<a id="more"></a>
<p>第二步：点击阅读原文</p>
<img src="/blog/2016/03/06/单击微信文章进入原文的方法/图二.png" alt="图二" title="图二">  
<p>第三步：到达原网页</p>
<img src="/blog/2016/03/06/单击微信文章进入原文的方法/图三.png" alt="图三" title="图三">
<hr>
<h4 id="期望流程">期望流程</h4><p>第一步：点击阅读原文</p>
<img src="/blog/2016/03/06/单击微信文章进入原文的方法/图四.png" alt="图四" title="图四">  
<p>第二步：到达原网页</p>
<img src="/blog/2016/03/06/单击微信文章进入原文的方法/图五.png" alt="图五" title="图五">  
<hr>
<p>期望的流程其实在2014年之前注册的公众号是有这个功能的，不过后来腾讯把公众号的好多功能都给限制了，至于其中缘由，我不清楚，也不想知道。那现在的公众号要怎样实现这个功能呢？通过分析有这种效果的公众号文章，发现这是一种“news”类型的消息，但是在微信开发文档的群发接口中：<a href="http://mp.weixin.qq.com/wiki/15/40b6865b893947b764e2de8e4a1fb55f.html" target="_blank" rel="external">http://mp.weixin.qq.com/wiki/15/40b6865b893947b764e2de8e4a1fb55f.html</a>，并没有真正的这种类型的消息，虽然有一种返回结果叫作“news”的东西，但是它并不是我们所期望的东西，还有一种叫作“mpnews”的消息，也不是我们期望的。后来在客服接口<a href="http://mp.weixin.qq.com/wiki/11/c88c270ae8935291626538f9c64bd123.html" target="_blank" rel="external">http://mp.weixin.qq.com/wiki/11/c88c270ae8935291626538f9c64bd123.html</a>中发现了这种类型的消息，抱着试一试的心态，居然成功了，当然了现在说起来很简单，但是在探索的阶段，它可是一个磨人的小妖精。</p>
<hr>
<p>下面是用php实现此功能的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span>	</span><br><span class="line">	set_time_limit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">encode2json</span><span class="params">(<span class="variable">$str</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> urldecode(json_encode(url_encode(<span class="variable">$str</span>)));	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">url_encode</span><span class="params">(<span class="variable">$str</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(is_array(<span class="variable">$str</span>)) &#123;</span><br><span class="line">			<span class="keyword">foreach</span>(<span class="variable">$str</span> <span class="keyword">as</span> <span class="variable">$key</span>=&gt;<span class="variable">$value</span>) &#123;</span><br><span class="line">				<span class="variable">$str</span>[urlencode(<span class="variable">$key</span>)] = url_encode(<span class="variable">$value</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="variable">$str</span> = urlencode(<span class="variable">$str</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$str</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">get_curl</span><span class="params">(<span class="variable">$url</span>)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!extension_loaded(<span class="string">'curl'</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'cURL library is not loaded'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="variable">$curl</span> = curl_init();       </span><br><span class="line">		curl_setopt(<span class="variable">$curl</span>, CURLOPT_URL, <span class="variable">$url</span>);       </span><br><span class="line">		curl_setopt(<span class="variable">$curl</span>, CURLOPT_SSL_VERIFYPEER, <span class="keyword">false</span>);</span><br><span class="line">		curl_setopt(<span class="variable">$curl</span>, CURLOPT_SSL_VERIFYHOST, <span class="number">2</span>);</span><br><span class="line">		curl_setopt(<span class="variable">$curl</span>, CURLOPT_TIMEOUT, <span class="number">30</span>); </span><br><span class="line">		curl_setopt(<span class="variable">$curl</span>, CURLOPT_RETURNTRANSFER, <span class="keyword">true</span>); </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$curl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">https_get</span><span class="params">(<span class="variable">$url</span>)</span></span><br><span class="line">	</span>&#123;       </span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="variable">$curl</span> = get_curl(<span class="variable">$url</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(<span class="keyword">Exception</span> <span class="variable">$e</span>)&#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="variable">$e</span>-&gt;getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="variable">$data</span> = curl_exec(<span class="variable">$curl</span>);       </span><br><span class="line">		<span class="keyword">if</span> (curl_errno(<span class="variable">$curl</span>)) &#123;</span><br><span class="line">			<span class="variable">$data</span> = encode2json(<span class="keyword">array</span>(<span class="string">'error'</span> =&gt; curl_error(<span class="variable">$curl</span>)));</span><br><span class="line">		&#125;       </span><br><span class="line">		curl_close(<span class="variable">$curl</span>);       </span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">https_post</span><span class="params">(<span class="variable">$url</span>, <span class="variable">$data</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="variable">$curl</span> = get_curl(<span class="variable">$url</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(<span class="keyword">Exception</span> <span class="variable">$e</span>)&#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="variable">$e</span>-&gt;getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="variable">$data_string</span> = encode2json(<span class="variable">$data</span>);</span><br><span class="line">		curl_setopt(<span class="variable">$curl</span>, CURLOPT_POST, <span class="number">1</span>);</span><br><span class="line">		curl_setopt(<span class="variable">$curl</span>, CURLOPT_POSTFIELDS, <span class="variable">$data_string</span>);</span><br><span class="line">		curl_setopt(<span class="variable">$curl</span>, CURLOPT_HTTPHEADER, <span class="keyword">array</span>(</span><br><span class="line">			<span class="string">'Content-Type: application/json; charset=utf-8'</span>,</span><br><span class="line">			<span class="string">'Content-Length: '</span> . strlen(<span class="variable">$data_string</span>))</span><br><span class="line">		);</span><br><span class="line">		<span class="variable">$data</span> = curl_exec(<span class="variable">$curl</span>);       </span><br><span class="line">		<span class="keyword">if</span> (curl_errno(<span class="variable">$curl</span>)) &#123;</span><br><span class="line">			<span class="variable">$data</span> = encode2json(<span class="keyword">array</span>(<span class="string">'error'</span> =&gt; curl_error(<span class="variable">$curl</span>)));</span><br><span class="line">		&#125;       </span><br><span class="line">		curl_close(<span class="variable">$curl</span>);       </span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//参考文档：http://mp.weixin.qq.com/wiki/14/9f9c82c1af308e3b14ba9b973f99a8ba.html</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">get_wechat_token</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="variable">$appid</span> = <span class="string">"xxxxxxxxxxxxxxxxxx"</span>;</span><br><span class="line">		<span class="variable">$appsecret</span> = <span class="string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="variable">$url</span> = <span class="string">"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$appid&amp;secret=$appsecret"</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="variable">$result</span> = json_decode(https_get(<span class="variable">$url</span>));</span><br><span class="line">		<span class="keyword">if</span>(property_exists(<span class="variable">$result</span>,<span class="string">'error'</span>))&#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="variable">$result</span>-&gt;error);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(!property_exists(<span class="variable">$result</span>,<span class="string">'access_token'</span>))&#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">'Get wechat token failed!'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		print_r(<span class="variable">$result</span>);</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$result</span>-&gt;access_token;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//参考文档：http://mp.weixin.qq.com/wiki/12/54773ff6da7b8bdc95b7d2667d84b1d4.html</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">get_brocast_user</span><span class="params">(<span class="variable">$token</span>)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="variable">$url</span> = <span class="string">"https://api.weixin.qq.com/cgi-bin/user/get?access_token=$token&amp;next_openid="</span>;</span><br><span class="line">		<span class="variable">$result</span> = json_decode(https_get(<span class="variable">$url</span>));</span><br><span class="line">		<span class="keyword">if</span>(property_exists(<span class="variable">$result</span>,<span class="string">'error'</span>))&#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="variable">$result</span>-&gt;error);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!property_exists(<span class="variable">$result</span>,<span class="string">'data'</span>))&#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">'Get wechat user failed!'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">			 </span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$result</span>-&gt;data-&gt;openid;		<span class="comment">// 获得所有用户的Openid</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//参考文档：</span></span><br><span class="line">	<span class="comment">//		1、接口文档：http://mp.weixin.qq.com/wiki/15/40b6865b893947b764e2de8e4a1fb55f.html</span></span><br><span class="line">	<span class="comment">//		2、news类型的消息（即：'msgtype'=&gt;'news'）参考文档：	</span></span><br><span class="line">	<span class="comment">//				http://mp.weixin.qq.com/wiki/11/c88c270ae8935291626538f9c64bd123.html</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">send_news</span><span class="params">(<span class="variable">$access_token</span>,<span class="variable">$arr</span>)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="variable">$url</span>  = <span class="string">"https://api.weixin.qq.com/cgi-bin/message/mass/send?access_token=$access_token"</span>;</span><br><span class="line">		<span class="variable">$data</span> = <span class="keyword">array</span>(</span><br><span class="line">					<span class="string">'touser'</span>=&gt;<span class="variable">$arr</span>,</span><br><span class="line">					<span class="string">'msgtype'</span>=&gt;<span class="string">'news'</span>,</span><br><span class="line">					<span class="string">'news'</span>=&gt;<span class="keyword">array</span>(</span><br><span class="line">						<span class="string">'articles'</span>=&gt;<span class="keyword">array</span>(</span><br><span class="line">							<span class="keyword">array</span>(</span><br><span class="line">								<span class="string">'title'</span>=&gt;<span class="string">'单击微信文章进入原文的方法'</span>,</span><br><span class="line">								<span class="string">'description'</span>=&gt;<span class="string">'微信公众号文章无需单击阅读原文直接进入到原文的方法'</span>,</span><br><span class="line">								<span class="string">'url'</span>=&gt;<span class="string">'http://t.cn/RGQwXwp'</span>,</span><br><span class="line">								<span class="string">'picurl'</span>=&gt;<span class="string">'http://t.cn/RGQwaVW'</span></span><br><span class="line">							)</span><br><span class="line">						)</span><br><span class="line">					)</span><br><span class="line">				); </span><br><span class="line"></span><br><span class="line">		<span class="variable">$return_content</span> = https_post(<span class="variable">$url</span>, <span class="variable">$data</span>);</span><br><span class="line">		print_r(<span class="variable">$return_content</span>);</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="variable">$access_token</span> = get_wechat_token();</span><br><span class="line">	<span class="variable">$users</span> = get_brocast_user(<span class="variable">$access_token</span>);</span><br><span class="line">	send_news(<span class="variable">$access_token</span>,<span class="variable">$users</span>);</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码中的$appid = “xxxxxxxxxxxxxxxxxx”;$appsecret = “xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx”;可以从微信公众平台的后台的“开发”菜单下的“基本配置”中得到，如图：</p>
<img src="/blog/2016/03/06/单击微信文章进入原文的方法/图六.png" alt="图六" title="图六">  
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天，一朋友因为我去年帮了她一点小忙而请吃了一顿豪华早茶，表示受之有愧，想想还是将这个方法分享一下。</p>
<p>需求：当公众号向订阅用户推送一篇文章后，用户单击文章直接进入文章的原文，而不是进入微信的一个页面，然后再单击阅读原文才能进入到原文的页面，（这样对于一个有动画效果的H5页面，直接进入原文，可以直接看到动画效果，否则，有些用户点开后进入到微信的一个页面，没有单击阅读原文，从而不会看到动画效果，而且大部分用户都不会点击阅读原文）。如图：</p>
<hr>
<h4 id="正常的流程：">正常的流程：</h4><p>第一步：点击阅读原文</p>
<img src="/blog/2016/03/06/单击微信文章进入原文的方法/图一.png" alt="图一" title="图一">]]>
    
    </summary>
    
      <category term="微信开发" scheme="http://hanhaichensha.coding.me/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
      <category term="微信开发" scheme="http://hanhaichensha.coding.me/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[计算机网络概述]]></title>
    <link href="http://hanhaichensha.coding.me/2015/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>http://hanhaichensha.coding.me/2015/11/26/计算机网络概述/</id>
    <published>2015-11-26T12:51:27.000Z</published>
    <updated>2016-11-04T05:54:16.265Z</updated>
    <content type="html"><![CDATA[<h3 id="基本原理">基本原理</h3><p>在《也说“当你输入一个网址，实际会发生什么?”》中介绍到，一台电脑要跟另一台电脑进行通信（所谓通信就是进行数据交换，比如：从其他电脑上下载一个文件到自己电脑等等，如果没有网络，我们一般的做法是使用U盘、光盘等存储设备将文件从某电脑上拷贝到U盘或者刻录到光盘，然后再把U盘或者光盘的文件拷贝到自己电脑上），说道一个重要的步骤就是找到想进行通信的计算机的IP地址（使用DNS协议实现），只是这样就能通信了吗？我只能说小伙子你真是“too young too simple”。这只是万里长征的一小步，为了后面知识点介绍的方便和对网络通信有大局观，现在先简单的概括性的对网络进行介绍。  </p>
<p>上篇日记中说到，在浏览器地址栏中输入www.baidu.com时，我们的计算机会把这个域名转换成IP地址，这个宏观过程就是之前讲过的DNS协议查询的那样，但是现在的问题是，本机也就是192.168.1.100去询问DNS服务器223.5.5.5 www.baidu.com的IP是多少时，本机和DNS服务器并不是用一根线直接相连的，而是通过网关和路由器间接相连，要把这个询问消息发送个DNS服务器，就必须要这些网关和路由器进行转发，使用ipconfig /all命令可以查看网关，如图：</p>
<a id="more"></a>
<img src="/blog/2015/11/26/计算机网络概述/图一.jpg" alt="图一" title="图一">  
<p>也就是说我先把信息发给网关或者路由器，如果只能使用IP来表示目标的话，那就只能先将目标设置为网关IP：192.168.1.100，但是当网关收到了这条消息后，网关不知道该怎么办，它该把这条消息发给谁呢？这显然是行不通的，当然这里可以使用广播，向与网关相连的所有的网关或这路由器都发送这条消息，其它机器使用同样的方法一直把消息传递给DNS服务器，然后DNS服务器使用同样的方法把响应回传。这种实现有一个很恐怖的地方，就拿网关A以及和网关A相连的另一个路由B来说，当网关把消息广播出去后，路由B会收到一条消息，然后路由B又将消息广播，此时网关A又会收到这条消息，然后A和B就传这条消息传到白头到老，地老天荒。如图：</p>
<img src="/blog/2015/11/26/计算机网络概述/图二.png" alt="图二" title="图二">  
<p>有人说这个比较容易解决，A传给B后，B传给除A外的其他机器，这样就不会出现这种传过来传回去的无限循环。传给出了除信息来源的其他机器，也就是说每传到一个机器后，要把信息里的源IP地址改变成机器自己的IP地址，这会出现当DNS服务器收到信息后不知道把信息回给谁？接着广播吗？就算这样行的通，这样真的能解决无限循环的问题吗？现在假设A将信息传给B，B传给除A外的其他机器，比如C，C收到信息，C将信息传给除B外的其他机器，比如A，又是一个天长地久，之前是两人的缠缠绵绵到天涯，现在是三人的纠葛漩涡。除此之外，这种方法带来的将是整个网络的瘫痪，进入流言满天飞，而且是永无停歇的境况。如图：</p>
<img src="/blog/2015/11/26/计算机网络概述/图三.png" alt="图三" title="图三">  
<p>这么看来这种方法是行不通的，那用什么办法可以解决呢？<br>既然是因为目标IP和源IP在传递的过程中一直在变化，那可以再添加一个地址，套一层壳，每次只换壳，目标IP永远不变，有句歌词怎么唱来着：“洋装虽然穿在身 我心依然是中国心”。正所谓初心不改，奋勇向前，总有一天会达成目标的。看一看具体的流程，本机将DNS消息和目标IP和自己IP以及网关的一个地址（目标地址）和自己的一个地址（源地址）,根据网关的这个地址，把信息发个网关，网关收到消息，根据目标IP选择一个目标路由器或主机，将消息中的目标地址改成路由或者主机的地址，将源地址改为网关自己的地址，根据目标地址，将消息发给路由或主机，以此类推一直到目标IP主机收到这个消息。消息回复，使用同样的方法。这样就完成了两台电脑之间的通信。</p>
<p>用什么地址可以唯一标识一台计算机呢？答案是MAC地址，每台计算机在生产的时候都会为其分配一个唯一的一个MAC地址。计算机之间的通信原理大致就是这样，具体细节，会在后面的文章中介绍。接下来，我们来大致理一理这个过程的稍微具体点的实现。</p>
<p>我们分别看看各个计算机的职责：</p>
<ol>
<li>发起通信的主机，主要职责：<ul>
<li>准备好要发送的用户信息；</li>
<li>找到目标主机IP地址和本机的IP地址；</li>
<li>将目标主机的的IP地址添加为信息的目标IP，将自己的IP地址添加为源IP，将其作为一整体，当作一条新的信息；</li>
<li>找到网关的MAC地址和本机的MAC地址；</li>
<li>在新的信息上添加网关MAC地址作为目标MAC地址，添加本机MAC地址作为源MAC地址；</li>
<li>根据目标MAC地址，将消息发送出去。</li>
</ul>
</li>
<li>网关或者路由，主要职责：<ul>
<li>将收到的信息进行解析，取出目标MAC地址，对比看看是不是自己的MAC地址；</li>
<li>如果是，则取出目标IP地址，看看离这个IP最近且与自己直接相连的路由或者主机，找出它的MAC地址，并且和它相连的网络接口，将目标MAC地址修改为最近的路由或者主机的MAC地址，将源MAC地址修改为网关或者路由自己的MAC地址，将消息从找到的网络接口发送出去。</li>
<li>如果不是，将消息丢弃。</li>
</ul>
</li>
<li>接收端的主机，主要职责：<ul>
<li>将收到的信息进行解析，取出目标MAC地址，对比看看是不是自己的MAC地址；</li>
<li>如果是本机MAC地址，取出目标IP，检查是不是本机IP；</li>
<li>如果不是本机MAC地址，丢弃此信息，不作后面的解析；</li>
<li>如果是本机IP地址，则取出信息，进行相应处理；</li>
<li>如果不是本机IP地址，则丢弃此消息；</li>
</ul>
</li>
</ol>
<p>从上面的职责，我们可以看出它们的主要职责有，用户信息处理，IP地址处理和MAC地址处理。源主机和目标主机这三个职责都有，只不过是过程向逆，三者都有的职责是IP地址处理和MAC地址处理。所以我们可以将这三个职责抽象出三个独立的处理模块，分别处理各自职责内的事情。将这三个模块组合起来就可以处理整个通信过程。而且从上面的过程可以明显的看出，这些处理过程有着层级关系，为了降低复杂性，我们对网络进行分层，将用户数据处理模块对应为应用层，IP地址处理模块对应为IP层，MAC地址处理模块对应为数据链路层。这就是计算机网络中的分层思想。</p>
<p>小伙伴们看到这，是不是要着急了。计算机网络的书本上明明白白说了OSI参考模型是七层，TCP/IP参考模型是四层，这里只有三层，明显是博主学艺不精。至于OSI参考模型这里就不说了，这个只是参考模型，在实现中并没有采用。TCP/IP参考模型的四层，再加上一层物理层（就是各类物理硬件），我们说的就是这个模型，下面将另外两层补上。</p>
<p>前面只是说到两台主机间的通信，我们忽略了物理设备这层（即各类硬件），把这层加上就足够两台主机通信了（当然这里可靠性之类的细节），也就是说，如果每台计算机只有一个使用网络的程序，那么理论上有这四层就能进行网络通信了，但是我们都知道，每台电脑上都有很多程序在使用网络，这就带了一个问题，计算机收到了来之网络上的信息，这条信息是要交给哪个应用程序的呢？我们可已使用上面的原理再加一层处理，网络分层也加一层，这一层处理的职责是在信息中添加一个ID标记（也就是端口）来标记这条消息是给哪个应用程序的，在接收端，根据这个ID（即端口）将信息交给对应的应用程序。加上这两层，就可以真真正正的实现通信了。</p>
<hr>
<h3 id="分层">分层</h3><p>下面来看看分层：网络协议通常分不同层次进行开发，每一层分别<br>负责不同的通信功能。这里不介绍物理层，这一层并非协议分层。</p>
<ol>
<li>链路层：通常包括操作系统中的设备驱动程序及接口卡。</li>
<li>网络层：处理分组在网络中的活动，包括协议有：IP、ICMP和IGMP。</li>
<li>运输层：或者叫做传输层，主要是为两台主机的应用程序提供端到端的通信，包括协议有：TCP和UDP。</li>
<li>应用层：负责处理特定应用程序的细节，包括协议有：Telnet、FTP、HTTP和e-mail等。</li>
</ol>
<p>用一张图来表示一下TCP/IP协议族中不同层次的协议，协议详情，以后在详陈：</p>
<img src="/blog/2015/11/26/计算机网络概述/图四.png" alt="图四" title="图四">
<hr>
<h3 id="封装">封装</h3><p>借助图四中的协议之间的箭头，我们来看看数据的组装（即箭头方向是从上向下的过程）和解析（即箭头方向是从下向上的过程）过程，这里的组装就是现在要将的封装，下一小节要说的分用就是解析过程。</p>
<p>封装过程如下：</p>
<ol>
<li>用户输入数据给应用程序，比如使用FTP的PWD命令显示当前目录，此时的数据就是：PWD。</li>
<li>FTP应用程序将此命令按FTP协议的规定将用户数据封装成FTP数据：PWD\r\r。</li>
<li>FTP将FTP数据交给TCP层，TCP层按照TCP协议加上TCP头，形成新的数据：TCP头+FTP数据。</li>
<li>TCP层将数据传给IP层，IP层按照IP协议加上IP头，形成新的数据：IP头+TCP头+FTP数据。</li>
<li>IP层将数据交给链路层，链路层按照链路层上的协议（一般是以太网协议）加上链路层协议头和链路层尾部，形成新的数据：以太网协议头+IP头+TCP头+FTP数据+以太网尾部。</li>
</ol>
<p>如下图所示：</p>
<img src="/blog/2015/11/26/计算机网络概述/图五.png" alt="图五" title="图五">
<hr>
<h3 id="分用">分用</h3><p>分用正好是封装的逆过程，此过程就不赘述了，这里说一个题外话，由以太网尾部联想到身份证最后一位的含义，它们的作用是一样的，都是一个校验作用。现在就让我们来看看身份证末尾出现X是怎么一回事：</p>
<p>公民身份号码是特征组合码，由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。</p>
<p>前面的17位是可以根据地区、出生年月和顺序码确定下来，最有一位的计算方法如下：</p>
<ol>
<li>将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。</li>
<li>将这17位数字和系数相乘的结果相加。</li>
<li>用加出来和除以11，看余数是多少？</li>
<li>余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X －9－8－7－6－5－4－3－2。</li>
</ol>
<p>从上面可以看出由于是对11取余数，所以有11个余数，而一位数只有10个，所以就出现了X。现在你可以用自己的身份证验证一下是不是这样的,如果你计算出来的结果与你身份证最后一位不一样，你的身份证就有问题了。还有一点：倒数第二数字，如果是奇数，则说明这个身份证号码是男性的，偶数则是女性的。</p>
<hr>
<p>参考资料：</p>
<ol>
<li>《TCP/IP详解：卷一》</li>
<li><a href="http://baike.baidu.com/view/188003.htm" target="_blank" rel="external">居民身份证号码</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="基本原理">基本原理</h3><p>在《也说“当你输入一个网址，实际会发生什么?”》中介绍到，一台电脑要跟另一台电脑进行通信（所谓通信就是进行数据交换，比如：从其他电脑上下载一个文件到自己电脑等等，如果没有网络，我们一般的做法是使用U盘、光盘等存储设备将文件从某电脑上拷贝到U盘或者刻录到光盘，然后再把U盘或者光盘的文件拷贝到自己电脑上），说道一个重要的步骤就是找到想进行通信的计算机的IP地址（使用DNS协议实现），只是这样就能通信了吗？我只能说小伙子你真是“too young too simple”。这只是万里长征的一小步，为了后面知识点介绍的方便和对网络通信有大局观，现在先简单的概括性的对网络进行介绍。  </p>
<p>上篇日记中说到，在浏览器地址栏中输入www.baidu.com时，我们的计算机会把这个域名转换成IP地址，这个宏观过程就是之前讲过的DNS协议查询的那样，但是现在的问题是，本机也就是192.168.1.100去询问DNS服务器223.5.5.5 www.baidu.com的IP是多少时，本机和DNS服务器并不是用一根线直接相连的，而是通过网关和路由器间接相连，要把这个询问消息发送个DNS服务器，就必须要这些网关和路由器进行转发，使用ipconfig /all命令可以查看网关，如图：</p>]]>
    
    </summary>
    
      <category term="计算机网络" scheme="http://hanhaichensha.coding.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机网络" scheme="http://hanhaichensha.coding.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[也说“当你输入一个网址，实际会发生什么?”]]></title>
    <link href="http://hanhaichensha.coding.me/2015/11/01/%E4%B9%9F%E8%AF%B4%E2%80%9C%E5%BD%93%E4%BD%A0%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%EF%BC%8C%E5%AE%9E%E9%99%85%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88-%E2%80%9D/"/>
    <id>http://hanhaichensha.coding.me/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/</id>
    <published>2015-11-01T12:02:55.000Z</published>
    <updated>2016-11-04T05:54:16.128Z</updated>
    <content type="html"><![CDATA[<p>趁着感冒好了，赶紧写个开篇，激励自己多写些东西。</p>
<p>问题来源：<a href="http://www.zhihu.com/question/34873227" target="_blank" rel="external">http://www.zhihu.com/question/34873227</a></p>
<p>最近也在各家公司面试，其中少不了会问到网络这一块的知识，借此机会整理一下网络知识。</p>
<p>一、准备工作：</p>
<p>使用到的工具有：</p>
<p>Dig for windows: <a href="http://download.csdn.net/download/tuberose1605/5818117" target="_blank" rel="external">http://download.csdn.net/download/tuberose1605/5818117</a></p>
<p>Dig程序安装步骤：</p>
<ol>
<li><p>将压缩包解压至 C:\dig ，复制 resolv.conf 至 C:\WINDOWS\system32\drivers\etc</p>
</li>
<li><p>添加环境变量</p>
<p>xp系统 我的电脑右键 – 属性 – 高级 – 环境变量 – 用户变量<br>win7系统 计算机右键 – 属性 – 高级系统设置 – 环境变量 – 用户变量<br>如果存在 PATH 变量，双击进入编辑模式，在变量值后面添加 ;c:\dig (;前面没有空格)<br>如果不存在，则新建变量 变量名：PATH 变量值：c:\dig<br>进入命令提示符，输入 dig 看是否安装成功。</p>
</li>
</ol>
<p>Wireshark: <a href="https://www.wireshark.org/#download" target="_blank" rel="external">https://www.wireshark.org/#download</a><br>Wireshark程序的安装没什么好说的，一般都是一路next就行了。<br><a id="more"></a><br>二、开始探索之旅：</p>
<p>以在chrome浏览器的地址栏输入：www.baidu.com为例来看看这个过程。</p>
<p>1．先打开wireshark：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图一.png" alt="图一" title="图一"><br>开始之后的界面如下图所示：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图二.png" alt="图二" title="图二"><br>现在在chrome浏览器中输入www.baidu.com，看看抓到的包是什么？</p>
<p>在输入www.baidu.com之前先单击重新开始抓包，然后在chrome的地址栏中输入www.baidu.com当页面加载完成之后，单击停止抓包，截图如下：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图三.png" alt="图三" title="图三"><br>从图中可以看出，访问www.baidu.com时，首先要进行的是把域名变成ip地址，也就是说电脑是通过ip找到要访问的电脑的，要找到域名对应的ip就要使用到DNS协议，今天重点看一下DNS的工作原理：</p>
<p>（一）DNS的工作原理</p>
<p>导航的第一步是通过访问的域名找出其IP地址。DNS查找过程如下：</p>
<ol>
<li><p>浏览器缓存 – 浏览器会缓存DNS记录一段时间。 有趣的是，操作系统没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。</p>
</li>
<li><p>系统缓存 – 如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用（windows里是gethostbyname）。这样便可获得系统缓存中的记录。</p>
</li>
<li><p>路由器缓存 – 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。</p>
</li>
<li><p>ISP DNS 缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。</p>
</li>
<li><p>递归搜索 – 你的ISP的DNS服务器从跟域名服务器开始进行递归搜索，从com.顶级域名服务器到baidu.com.的域名服务器。一般DNS服务器的缓存中会有com.域名服务器中的域名，所以到顶级服务器的匹配过程不是那么必要了。</p>
</li>
</ol>
<p>这里简单的介绍一下系统缓存，缓存就是指不用你每次去访问www.baidu.com时，都向网络发一条DNS数据包，系统会在你第一次访问www.baidu.com时，会将www.baidu.com对应的ip地址保存在本机，下次再访问www.baidu.com时，就能直接得到ip地址了。要查看本机的dns缓存，使用使用cmd，输入ipconfig /displaydns命令就可以看到缓存了，比如百度的：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图四.png" alt="图四" title="图四"><br>它对应的是一条CNAME记录。而formi.baidu.com对应的是两条A记录：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图五.png" alt="图五" title="图五"><br>A记录是主机名或者域名所及对应的ip的一条记录，而CNAME记录是A记录的别名的一条记录。也就是说www.baidu.com只是www.a.shifen.com的一个别名。上面是显示系统已经缓存的dns。如果要抓包的话，有的时候由于缓存还在存活期，此时访问www.baidu.com时，就不会发出DNS包，这个时候你可选择等待一段时间再进行抓包，这当然是比较愚蠢的做法，此时你可以使用ipconfig /flushdns命令来清除这些缓存记录。</p>
<p>接着分析发送的第一个DNS包：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图六.png" alt="图六" title="图六"><br>这里面有两个ip地址，一个是Source：192.168.1.105和Destination：223.5.5.5，这两个ip代表了什么呢？我们想要知道www.baidu.com的ip地址，但是本地又没有www.baidu.com对应的ip地址，此时我们要怎么知道这个ip地址呢？自己不知道那就去问别人咯，那该问谁呢，谁会知道这ip呢？这是你在设置网络的时候填写的，在网络连接的属性中可以设置，如图：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图七.png" alt="图七" title="图七"><br>看到了吗，223.5.5.5，你也可以使用cmd中的ipconfig /all命令查看这些信息，如图：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图八.png" alt="图八" title="图八"><br>图中圈起来的是比较重要的信息。当然你也可以不用这样设置，而是使用上面的自动获得DNS服务器地址，而不是手动设置，你依然可以使用上面的命令ipconfig /all来查看这些信息。现在我们知道了Source：192.168.1.105是本机的局域网ip地址，而Destination：223.5.5.5是阿里的免费DNS服务器的公有ip地址。它是浙江省杭州市电信的一个ip地址。注意了：Source是一个局域网的ip地址，Destination是一个公有ip地址，记住这个是有区别的，这个留着以后解释，为了方便理解，就当它们没有区别，如果你想知道你的公有ip地址，可以在百度中输入ip即可以搜索到，如图：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图九.png" alt="图九" title="图九"><br><br>理解了这些，接着往下看，192.168.1.105问223.5.5.5：你知道www.baidu.com的ip是多少吗？这个时候233.5.5.5它会怎么办呢？如果233.5.5.5已经有这条记录的缓存，就告诉192.168.1.105这条记录的ip（这个过程比较复杂，这里省略，以后详解），233.5.5.5这就是使用了ISP DNS 缓存，如果233.5.5.5也没有缓存这条记录怎么办？这个时候就要向其它服务器要了，那它又向谁要呢？这个时候就要它就会向DNS根服务器要，在进入到DNS服务器查询前，先来了解一下域名：一般来说域名都是xxx.xxx.xxx，比如：www.baidu.com就是这样的一个，所谓域名，就是用来确定域的，而且域与域是使用“.”分割，而且越后面的域越高，范围越大，如：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十一.png" alt="图十一" title="图十一"><br>DNS有两种查询解析方式：</p>
<p>一、192.168.1.105询问223.5.5.5，223.5.5.5将DNS根服务器ip地址列表返回给192.168.1.105，192.168.1.105再询问DNS根服务器，DNS根服务器收到查询后，查询出顶级域是com.的服务器的ip列表返回给192.168.1.105，接着192.168.1.105询问com.域服务器，com.域服务器将baidu.com.域服务器的ip列表返回给192.168.1.105，192.168.1.105再去询问baidu.com.域服务器，如果有该记录，就将相应的ip返回给192.168.1.105。</p>
<p>二、第二种方式的是192.168.1.105询问223.5.5.5，223.5.5.5询问根服务器，根服务器询问com.服务器，com.服务器询问baidu.com.服务，baidu.com.服务返回给com.服务器，com.服务器返回给根服务器，根服务器返回个223.5.5.5，233.5.5.5返回给192.168.1.105。</p>
<p>下面使用dig来看看方式一这个过程，如图：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十二.png" alt="图十二" title="图十二"><br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十三.png" alt="图十三" title="图十三"><br>附上一张因特网域名空间：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十四.png" alt="图十四" title="图十四"><br>DNS的工作过程大致就是这样，不过这并不是完整过程。最后来看一看DNS数据包，DNS查询和应答报文格式：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十五.png" alt="图十五" title="图十五"><br>标识（2字节）：这个字段是一对DNS查询和应答唯一标识，其实就是A向B问了一个问题用类似A1这样的id表示这个问题，等B有时间处理了这个问题告诉A时，就告诉A我现在回答的是A1这个问题。</p>
<p>标志（2字节）：这部分非常重要，是通信方式和反馈状态的一些标志位。再借个图：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十六.png" alt="图十六" title="图十六"><br>QR(1比特）：查询/响应的标志位，1为响应，0为查询。</p>
<p>opcode（4比特）：定义查询或响应的类型（若为0则表示是标准的，若为1则是反向的，若为2则是服务器状态请求）。</p>
<p>AA（1比特）：授权回答的标志位。该位在响应报文中有效，1表示名字服务器是权限服务器</p>
<p>TC（1比特）：截断标志位。1表示响应已超过512字节并已被截断，仅当DNS报文使用UDP服务器是使用，因为UDP数据报有长度限制，所以过长的DNS报文将被阶段。</p>
<p>RD（1比特）：该位为1表示客户端希望得到递归回答（这就是上文提到的方式二），0表示迭代查询（即上文提到的方式一）</p>
<p>RA（1比特）：只能在响应报文中置为1，表示可以得到递归响应。</p>
<p>zero（3比特）：不说也知道都是0了，保留字段。</p>
<p>rcode（4比特）：返回码，表示响应的差错状态，通常为0和3，各取值含义如下：</p>
<pre><code><span class="number">0</span>          无差错
<span class="number">1</span>          格式差错
<span class="number">2</span>          问题在域名服务器上
<span class="number">3</span>          域不存在
<span class="number">4</span>          查询类型不支持
<span class="number">5</span>          在管理上被禁止
<span class="number">6</span>          -- <span class="number">15</span> 保留
</code></pre><p>接下来的4个字段分别表示DNS报文最后4个字段的资源记录数目。对查询报文而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。应答报文的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。</p>
<p>查询问题的格式：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十七.png" alt="图十七" title="图十七"><br>查询名部分长度不定，一般为要查询的域名（也会有IP的时候，即反向查询）。此部分由一个或者多个标示符序列组成，每个标示符以首字节数的计数值来说明该标示符长度，每个名字以0结束。计数字节数必须是0~63之间。该字段无需填充字节。还是借个例子来说明更直观些，查询名为www.baidu.com.<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十八.png" alt="图十八" title="图十八"><br>查询类型有：类型A，值为1，表示获取目标主机的IP地址，类型CNAME，值为5，表示获得目标主机的别名，类型PTR，值12，表示反向查询（在windows下有个命令nslookup IP，查询出域名）。</p>
<p>查询类通常是1，表示获取因特网地址（即IP地址）。</p>
<p>应答字段、授权字段和额外信息字段都使用资源记录（Resource Record，RR）格式，如图：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图十九.png" alt="图十九" title="图十九"><br>域名字段（不定长或2字节）：记录中资源数据对应的名字，它的格式和查询名字段格式相同。当报文中域名重复出现时，就需要使用2字节的偏移指针来替换。例如，在资源记录中，域名通常是查询问题部分的域名的重复，就需要用指针指向查询问题部分的域名。关于指针怎么用，TCP/IP详解里面有，即2字节的指针，最前面的两个高位是11，用于识别指针。其他14位从报文开始处计数（从0开始），指出该报文中的相应字节数。注意，DNS报文的第一个字节是字节0，第二个报文是字节1。一般响应报文中，资源部分的域名都是指针C00C(1100000000001100)，刚好指向查询问题部分的查询名。</p>
<p>类型（2字节）、类（2字节）：含义与查询问题部分的类型和类相同。</p>
<p>生存时间（4字节）：该字段表示资源记录的生命周期（以秒为单位），一般用于当地址解析程序取出资源记录后决定保存及使用缓存数据的时间。</p>
<p>资源数据长度（2字节）：取决于类型字段，对于类型A而言，资源数据是32位的IPv4地址，而资源数据长度则为4（以字节为单位）</p>
<p>资源数据：该字段是可变长字段，表示按查询段要求返回的相关资源记录的数据。</p>
<p>结合wireshark抓到的包来看看：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图二十.png" alt="图二十" title="图二十"><br>这两条DNS报文就是一对，圈起来的就是标识：0X4d51，先看查询报文：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图二十一.png" alt="图二十一" title="图二十一"><br>再来看应答报文：<br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图二十二.png" alt="图二十二" title="图二十二"><br><img src="/blog/2015/11/01/也说“当你输入一个网址，实际会发生什么-”/图二十三.png" alt="图二十三" title="图二十三"><br>未完待续……</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>趁着感冒好了，赶紧写个开篇，激励自己多写些东西。</p>
<p>问题来源：<a href="http://www.zhihu.com/question/34873227">http://www.zhihu.com/question/34873227</a></p>
<p>最近也在各家公司面试，其中少不了会问到网络这一块的知识，借此机会整理一下网络知识。</p>
<p>一、准备工作：</p>
<p>使用到的工具有：</p>
<p>Dig for windows: <a href="http://download.csdn.net/download/tuberose1605/5818117">http://download.csdn.net/download/tuberose1605/5818117</a></p>
<p>Dig程序安装步骤：</p>
<ol>
<li><p>将压缩包解压至 C:\dig ，复制 resolv.conf 至 C:\WINDOWS\system32\drivers\etc</p>
</li>
<li><p>添加环境变量</p>
<p>xp系统 我的电脑右键 – 属性 – 高级 – 环境变量 – 用户变量<br>win7系统 计算机右键 – 属性 – 高级系统设置 – 环境变量 – 用户变量<br>如果存在 PATH 变量，双击进入编辑模式，在变量值后面添加 ;c:\dig (;前面没有空格)<br>如果不存在，则新建变量 变量名：PATH 变量值：c:\dig<br>进入命令提示符，输入 dig 看是否安装成功。</p>
</li>
</ol>
<p>Wireshark: <a href="https://www.wireshark.org/#download">https://www.wireshark.org/#download</a><br>Wireshark程序的安装没什么好说的，一般都是一路next就行了。<br>]]>
    
    </summary>
    
      <category term="计算机网络" scheme="http://hanhaichensha.coding.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机网络" scheme="http://hanhaichensha.coding.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
