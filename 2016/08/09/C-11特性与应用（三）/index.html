<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>C++11特性与应用（三） | 翰海尘沙</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="基于范围的for循环基于范围的for循环非常的简洁，如：1234567891011121314151617181920212223242526#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;// C++11版本int main(void)&amp;#123;        std::vector&amp;lt;int&amp;gt; arr = &amp;#123; 1, 2, 3">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11特性与应用（三）">
<meta property="og:url" content="http://hanhaichensha.coding.me/2016/08/09/C-11特性与应用（三）/index.html">
<meta property="og:site_name" content="翰海尘沙">
<meta property="og:description" content="基于范围的for循环基于范围的for循环非常的简洁，如：1234567891011121314151617181920212223242526#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;// C++11版本int main(void)&amp;#123;        std::vector&amp;lt;int&amp;gt; arr = &amp;#123; 1, 2, 3">
<meta property="og:updated_time" content="2016-11-04T05:54:16.087Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++11特性与应用（三）">
<meta name="twitter:description" content="基于范围的for循环基于范围的for循环非常的简洁，如：1234567891011121314151617181920212223242526#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;// C++11版本int main(void)&amp;#123;        std::vector&amp;lt;int&amp;gt; arr = &amp;#123; 1, 2, 3">
  
    <link rel="alternative" href="/blog/atom.xml" title="翰海尘沙" type="application/atom+xml">
  
  
    <link rel="icon" href="/blog/css/images/favicon.jpg">
  
  <link href="/blog/css/font.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">翰海尘沙</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">进击的程序员</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">主页</a>
        
          <a class="main-nav-link" href="/blog/archives/">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/s" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="wd" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hanhaichensha.coding.me"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-C-11特性与应用（三）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/08/09/C-11特性与应用（三）/" class="article-date">
  <time datetime="2016-08-09T09:33:54.000Z" itemprop="datePublished">2016-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++11特性与应用（三）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基于范围的for循环">基于范围的for循环</h3><p>基于范围的for循环非常的简洁，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : arr)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++98/03版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = arr.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; it != arr.end(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相比之下，C++版本更加简洁。</p>
<h4 id="基于范围的for循环使用细节">基于范围的for循环使用细节</h4><p>注意到基于范围的for循环中的auto n，推导出来的是int类型，也就是说<strong>auto推导出来的类型是容器的value_type，而不是迭代器</strong>。</p>
<p>看到for (auto n : arr)这句，有人会怀疑对容器的访问是没取一个值访问一次容器。事实真是这样吗？我们可以用下面的代码验证一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; get_range(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val : get_range())</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line">get_range</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>从上面的结果可以看出，for (auto val : get_range())对容器只访问了一次。说明<strong>基于范围的for循环，冒号后面的表达式只会被执行一次</strong></p>
<p>在遍历时，对容器进行修改的情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> val : arr)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">                arr.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"=================================="</span> &lt;&lt; <span class="built_in">std</span>::endl;<span class="keyword">for</span>(<span class="keyword">auto</span> val : arr)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">==================================</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>上面输出结果是在gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1)环境下的输出结果。对于同的编译器有不同的结果，随意在遍历容器时，尽量不要修改容器。而且可以看来上面的第一次变量虽然改变了容器，但是，遍历次数并没有增加。基于范围的for循环其实是普通for循环的语法糖，它等效下面的循环(参考ISO/IEC 14882 2014, 6.5.4 The range-based for statement)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> val : arr)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        arr.push_back(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面几句，等效于下面语句</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> &amp;&amp; __range = (arr);</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">auto</span> __begin = __range.begin(),__end = __range.end(); __begin != __end; ++__begin ) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> val = *__begin;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        arr.push_back(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的分析，我们知道只要一个容器实现了如下功能就能自定义一个容器，使得它也可以使用基于范围的for循环：</p>
<ol>
<li>容器要提供begin()和end()接口，返回一个该容器的迭代器；</li>
<li>容器的迭代器，实现重载前置++、解引用*和!=运算符；</li>
</ol>
<p>只要实现了上面两个要求，就可以将此自定义对象进行范围for循环了，下面实现一个针对整数的不完整实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> range_container</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> iterator</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> cursor_;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		iterator(<span class="keyword">int</span> cursor):cursor_(cursor)&#123;&#125;</span><br><span class="line">		<span class="keyword">int</span> <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> cursor_;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; rhs) <span class="keyword">const</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> cursor_ != rhs.cursor_;</span><br><span class="line">		&#125;</span><br><span class="line">		iterator&amp; <span class="keyword">operator</span>++(<span class="keyword">void</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			++cursor_;</span><br><span class="line">			<span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">class</span> container</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">using</span> const_iterator = <span class="keyword">const</span> range_container::iterator;</span><br><span class="line">		<span class="keyword">int</span> begin_;</span><br><span class="line">		<span class="keyword">int</span> end_;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		container(<span class="keyword">int</span> begin, <span class="keyword">int</span> end):begin_(begin),end_(end + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">const_iterator <span class="title">begin</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;begin_&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">const_iterator <span class="title">end</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;end_&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">&#125;<span class="comment">// range_container namespace end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        range_container::container c&#123; <span class="number">1</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> val : c)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="函数包装器和绑定器">函数包装器和绑定器</h3><h4 id="可调用对象">可调用对象</h4><p>在C++中有一下几种对象可以作为可调用对象，也就是可以进行函数调用：</p>
<ol>
<li>函数指针；</li>
<li>仿函数，具有operator()成员函数的类对象；</li>
<li>可以转换为函数指针的类对象，重载了类型转换符，并返回一个函数指针；</li>
<li>类成员函数指针；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Bar</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">fr_t</span> = <span class="keyword">void</span>(*)(<span class="keyword">void</span>);</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">fr_t</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> func;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mem_func</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> (*func_ptr)(<span class="keyword">void</span>) = &amp;func;		<span class="comment">//1、函数指针</span></span><br><span class="line">	func_ptr();</span><br><span class="line"></span><br><span class="line">	Foo foo;							<span class="comment">//2、仿函数</span></span><br><span class="line">	foo();</span><br><span class="line"></span><br><span class="line">	Bar bar;							<span class="comment">//3、可以转换为函数指针的类对象</span></span><br><span class="line">	bar();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (A::*mem_func_ptr)(<span class="keyword">void</span>) = &amp;A::mem_func;</span><br><span class="line">	A aa;</span><br><span class="line">	(aa.*mem_func_ptr)();				<span class="comment">//4、类成员函数指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可调用对象的类型称为<strong>可调用类型</strong>。</p>
<h4 id="std::function函数包装器">std::function函数包装器</h4><p>现在思考一问题，以上的可调用类型都可充当一个回调函数类型传递给一个接口，由于可调用类型这么多，我们必须的将接口进行多次重载。如果你知道可调用对象包装器，你就无需进行重载了。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a &amp; <span class="number">0x01</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Even</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a &amp; <span class="number">0x01</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Bar</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isEven_static</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a &amp; <span class="number">0x01</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> FuncTest</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; callback_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	FuncTest(<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; func):callback_(func)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(callback_(i))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">FuncTest <span class="title">ft1</span><span class="params">(isEven)</span></span>;					<span class="comment">//1、函数指针</span></span><br><span class="line">	ft1.output();</span><br><span class="line"></span><br><span class="line">	Even even;							<span class="comment">//2、仿函数</span></span><br><span class="line">	<span class="function">FuncTest <span class="title">ft2</span><span class="params">(even)</span></span>;</span><br><span class="line">	ft2.output();</span><br><span class="line"></span><br><span class="line">	<span class="function">FuncTest <span class="title">ft3</span><span class="params">(Bar::isEven_static)</span></span>;		<span class="comment">//3、静态成员函数指针</span></span><br><span class="line">	ft3.output();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">==========================</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">==========================</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>从上面的例子中可以看到，std::function函数包装器可以接收如下可调用对象：</p>
<ol>
<li>函数指针；</li>
<li>仿函数；</li>
<li>可以转换为函数指针的类对象，更准确应该是静态成员函数指针。</li>
</ol>
<p>可以看到，std::function函数包装器不能容纳<strong>类成员函数指针</strong>，会报下面错误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Bar</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a &amp; <span class="number">0x01</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> (Bar::*func_ptr)(<span class="keyword">int</span>) = &amp;Bar::isEven;</span><br><span class="line">	Bar bar;			</span><br><span class="line">	<span class="function">FuncTest <span class="title">ft1</span><span class="params">(bar.*func_ptr)</span></span>;				<span class="comment">//4、类成员函数指针</span></span><br><span class="line">	ft1.output();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line">error: invalid use of non-<span class="function"><span class="keyword">static</span> member function</span><br><span class="line">  FuncTest <span class="title">ft1</span><span class="params">(bar.*func_ptr)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>也就是说只有是类成员是静态函数指针才能被std::function函数包装器容纳。其实在可以转换为函数指针的类对象中，重载类型转换符，返回的就是一个静态成员函数的指针。</p>
<h4 id="std::bind绑定器">std::bind绑定器</h4><p>不知道大家有没有写过类似如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_1</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	output_1(a);</span><br><span class="line">	output_2(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_3</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	output_2(<span class="number">100</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_4</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	output_2(a, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总觉的上面的代码有点别扭，如果output_3和output_4中的常数多出一种情况50，又得添加两个函数接口，十分麻烦。这时如果你使用std::bind绑定器，将可调用对象和它的函数进行绑定，那么将会很方便，你只需要定义output_1和output_2两个接口，让接口调用这使用std::bind创建出他们希望的固定参数值的output了。如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// API </span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_1</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	output_1(a);</span><br><span class="line">	output_2(b);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// Caller</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> output_3 = <span class="built_in">std</span>::bind(output_2,<span class="number">100</span>,<span class="built_in">std</span>::placeholders::_1);		<span class="comment">//即效果如output_2(100,a);</span></span><br><span class="line">	<span class="keyword">auto</span> output_4 = <span class="built_in">std</span>::bind(output_2,<span class="built_in">std</span>::placeholders::_1,<span class="number">100</span>);		<span class="comment">//即效果如output_2(a,100);</span></span><br><span class="line">	output_3(<span class="number">3</span>);		<span class="comment">//相当于调用output_2(100,3)效果</span></span><br><span class="line">	output_4(<span class="number">4</span>);		<span class="comment">//相当于调用output_2(4,100)效果</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="number">100</span>		<span class="number">3</span></span><br><span class="line"><span class="number">4</span>		<span class="number">100</span></span><br></pre></td></tr></table></figure></p>
<p>std::bind用法说明：</p>
<ol>
<li>参数一，要绑定的函数（如上output_2）;</li>
<li>参数二，传给绑定函数的第一个参数（如上，100传给output_2，即output_2(100,x)，x表示未知参数），参数三，传给绑定函数的第二个参数，以此类推；</li>
<li>如果参数是std::placeholders，std::placeholders::_1表示将调用绑定生成函数的第一个参数传递到std::placeholders::_1所在位置（如上，绑定生成的函数output_3，调用时output_3(3)，此时会将参数3传递到std::bind(output_2,100,<strong>3</strong>)，接着会解析成output_2(100,3)，以此类推std::placeholders::_2。</li>
</ol>
<p>std::bind绑定器的作用：</p>
<ol>
<li>将可调用对象与其参数一起绑定成一个仿函数。</li>
<li>将多元（参数个数为n，n&gt;1）可调用对象转换成一元或者（n-1）元可调用对象，即部分参数绑定。</li>
</ol>
<p>绑定一个成员函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"\t"</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; fr = <span class="built_in">std</span>::bind(&amp;A::output,&amp;a,<span class="built_in">std</span>::placeholders::_1,<span class="built_in">std</span>::placeholders::_2);</span><br><span class="line">	fr(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="number">1</span>	<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码可以看出：</p>
<ol>
<li>std::bind的返回值是std::function；</li>
<li>std::bind绑定成员函数时，第一参数是成员函数指针，第二参数是对象指针（相当于将this指针作为第一个参数传递给成员函数，在C++中，这通常是一个隐含参数），这也就将成员函数和对象绑定了，第三给参数是传递给成员函数的第一个参数，以此类推其他参数。</li>
</ol>
<p>知道std::bind绑定类成员的方法，我们就可利用这个方法来解决：std::function函数包装器不能容纳类成员函数指针问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Bar</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a &amp; <span class="number">0x01</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> FuncTest</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; callback_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	FuncTest(<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; func):callback_(func)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(callback_(i))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Bar bar;</span><br><span class="line">	<span class="keyword">auto</span> fr = <span class="built_in">std</span>::bind(&amp;Bar::isEven,&amp;bar,<span class="built_in">std</span>::placeholders::_1);</span><br><span class="line">		</span><br><span class="line">	<span class="function">FuncTest <span class="title">ft1</span><span class="params">(fr)</span></span>;</span><br><span class="line">	ft1.output();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>问题得到解决。</p>
<p>std::bind的组合使用<br>使用绑定器和逻辑函数将多个函数组合成一个复合函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::placeholders::_1;</span><br><span class="line"><span class="keyword">auto</span> func = <span class="built_in">std</span>::bind(<span class="built_in">std</span>::logical_and&lt;boo&gt;(),</span><br><span class="line">					  <span class="built_in">std</span>::bind(<span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">5</span>),</span><br><span class="line">		  			  <span class="built_in">std</span>::bind(<span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">10</span>)</span><br><span class="line">		 			 );</span><br><span class="line"><span class="comment">// 查找集合中大于5小于10的元素个数</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="built_in">std</span>::count_if(container.begin(),container.end(),func);</span><br></pre></td></tr></table></figure></p>
<h3 id="lambda表达式">lambda表达式</h3><p>知道可调用对象之后，我们在传递一个可调用对象的时候就可以定义一个可调用对象传递过去，但是对于一些复用次数不多，处理过程简单的处理代码，为此特意定义一个可调用对象，显得大材小用。lambda就能很好的解决这个问题。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可调用对象版，使用仿函数</span></span><br><span class="line"><span class="keyword">class</span> Even</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(a &amp; <span class="number">0x01</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">Even isEven;</span><br><span class="line">for_each(vec.begin(), vec.end(), isEven);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda版</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">for_each(vec.begin(), vec.end(), [](<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(a &amp; <span class="number">0x01</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，lambda表达式使代码更可读，更简洁，上例或许还看不出多少简洁成分，可以看下例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找集合中大于5小于10的元素个数，std::function和std::bind版本</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::placeholders::_1;</span><br><span class="line"><span class="keyword">auto</span> func = <span class="built_in">std</span>::bind(<span class="built_in">std</span>::logical_and&lt;boo&gt;(),</span><br><span class="line">					  <span class="built_in">std</span>::bind(<span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">5</span>),</span><br><span class="line">		  			  <span class="built_in">std</span>::bind(<span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">10</span>)</span><br><span class="line">		 			 );</span><br><span class="line"><span class="keyword">int</span> count = <span class="built_in">std</span>::count_if(container.begin(),container.end(),func);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找集合中大于5小于10的元素个数，lambda版本</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="built_in">std</span>::count_if(container.begin(),container.end(),[](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x &gt; <span class="number">5</span> &amp;&amp; x &lt; <span class="number">10</span>;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>lambda表达式源于函数式编程的概念，有如下优点：</p>
<ol>
<li>声明式编程风格：就地定义匿名目标函数或函数对象（即可调用对象）；</li>
<li>简洁：不需要定义具名函数或者函数对象；</li>
<li>在需要的时间和地点实现功能闭包，使程序更灵活。</li>
</ol>
<h4 id="lambda表达式概念">lambda表达式概念</h4><p>lambda语法格式：<br>[ capture ] ( params ) opt -&gt; ret { body; };<br>说明：</p>
<ol>
<li>captura是捕获列表；</li>
<li>params是参数列表，在参数列表没有参数时，可以省略参数列表（包括左右括号）；</li>
<li>opt是函数选项，如mutable；</li>
<li>ret是返回值类型，可以根据returned语句自动推导返回值类型，但是初始化列表不能用于推导，此时要显示写明返回值类型；</li>
<li>body是函数体。</li>
</ol>
<p>捕获列表可以如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">捕获列表</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[]</td>
<td style="text-align:center">不捕获任何变量</td>
</tr>
<tr>
<td style="text-align:center">[&amp;]</td>
<td style="text-align:center">以引用的方式捕获外部作用域中的所有变量</td>
</tr>
<tr>
<td style="text-align:center">[=]</td>
<td style="text-align:center">以值的方式捕获外部作用域中的所有变量</td>
</tr>
<tr>
<td style="text-align:center">[=,&amp;foo]</td>
<td style="text-align:center">按值捕获外部作用域中的所有变量，按引用捕获foo</td>
</tr>
<tr>
<td style="text-align:center">[foo]</td>
<td style="text-align:center">只按值捕获foo，其他变量都不捕获</td>
</tr>
<tr>
<td style="text-align:center">[this]</td>
<td style="text-align:center">捕获当前类中的this指针，与类成员函数一样的访问权限，[&amp;]或[=]包括this在内</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ol>
<li><p><strong>按值捕获的变量是在定义lambda表达式时变量的复制品，当外部作用域改变该值时，不影响lambda中捕获的值</strong>。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> func = [=]&#123;<span class="keyword">return</span> a;&#125;;				<span class="comment">//按值捕获</span></span><br><span class="line"></span><br><span class="line">a += <span class="number">1</span>;									<span class="comment">//修改外部值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func() &lt;&lt; <span class="built_in">std</span>::endl;		<span class="comment">//输出是0，不是1，因为func中是按值a,捕获的a其实是a的一个复制品，外部值改变不影响lambda这个闭包中的值。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>按值捕获的变量，在lambda中无法修改，如需修改，添加函数选项mutable，但是由于是按值捕获，在lambda中修改捕获值也不会影响外部变量的值，使用mutable时，就算没有参数参数列表也不能省略</strong>。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> func1 = [=]&#123;<span class="keyword">return</span> a++;&#125;;				<span class="comment">//error,无法修改</span></span><br><span class="line"><span class="keyword">auto</span> func2 = [=]() <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> a++;&#125;;	<span class="comment">//ok，mutable可以修改</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>lambda表达式类型在C++11中称为“闭包类型”，它是一种特殊的、匿名的非non-union的类类型。我们可以将它看作一个带有operator()的类，即仿函数。它可以使用std::function和std::bind来存储和操作lambda表达式。在上文中说道std::function函数包装器可以接收<strong>函数指针</strong>、<strong>仿函数</strong>、<strong>静态成员函数指针</strong>，现在还可以加上<strong>lambda表达式</strong>。例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func1 = [](<span class="keyword">int</span> a)&#123; <span class="keyword">return</span> a;&#125;;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func2 = <span class="built_in">std</span>::bind([](<span class="keyword">int</span> a)&#123;<span class="keyword">return</span> a;&#125;,<span class="built_in">std</span>::placeholders::_1);</span><br></pre></td></tr></table></figure></p>
<p>lambda表达式可以说是就地定义仿函数闭包的“语法糖”，它捕获的变量成为了闭包成员变量。按照C++标准，lambda表达式的operator()默认是const的，所以无法修改捕获到的变量。如果将lambda表达转换成函数指针，此时会丢失lambda闭包的this指针，对于无捕获列表的lambda表达式没什么问题，但是对于有捕获列表的将会报错，编译通不过。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*ptr)</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line">ptr p1 = [](<span class="keyword">int</span>* p) &#123;<span class="keyword">delete</span> p;&#125;;	<span class="comment">//ok</span></span><br><span class="line">ptr p2 = [&amp;](<span class="keyword">int</span> *p) &#123;<span class="keyword">delete</span> p;&#125;;	<span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>C++11引入函数表达式，让代码更简洁，更灵活，更强大，挺提高了开发效率和提高了可维护性。</p>
<h3 id="tuple元组">tuple元组</h3><p>tuple元组是一个固定大小的不同类型值的集合，是泛化的std::pair。</p>
<ol>
<li>构造tuple：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tp(<span class="number">1</span>,<span class="number">2</span>);	<span class="comment">//ok</span></span><br><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tp&#123;<span class="number">1</span>,<span class="number">2</span>);	<span class="comment">//ok</span></span><br><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tp = &#123; <span class="number">1</span>, <span class="number">2</span>&#125;;	<span class="comment">//error,tuple构造函数被explicit限定</span></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line">tuple&lt;<span class="keyword">const</span> <span class="keyword">char</span>*,<span class="keyword">int</span>&gt; tp = <span class="built_in">std</span>::make_tuple(sendPack,nSendSize);</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> *pack;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：</span></span><br><span class="line"><span class="keyword">auto</span> tp = <span class="keyword">return</span> <span class="built_in">std</span>::tie(<span class="number">1</span>,<span class="string">"aa"</span>,<span class="number">2</span>);	<span class="comment">//实际类型：std::tuple&lt;int&amp;,string&amp;,int&amp;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法四：</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"aa"</span>;</span><br><span class="line"><span class="keyword">auto</span> tp = <span class="built_in">std</span>::make_tuple(ref(a),ref(s),ref(b));	<span class="comment">//实际类型：std::tuple&lt;int&amp;,string&amp;,int&amp;)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>说明：tuple构造函数被explicit限定，不能进行隐式转换，不可以将初始化列表传至“期望获取一个tuple”的地方，而是使用make_tuple。通过std::tie创建的元组是一个左值引用元组。</p>
<ol>
<li><p>获取元组值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* data = get&lt;<span class="number">0</span>&gt;(tp);</span><br><span class="line"><span class="keyword">int</span> len = get&lt;<span class="number">1</span>&gt;(tp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">string</span> a;</span><br><span class="line"><span class="built_in">std</span>::tie(x,a,y) = tp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果只想获取某个值</span></span><br><span class="line"><span class="built_in">std</span>::tie(<span class="built_in">std</span>::ignore,<span class="built_in">std</span>::ignore,y) = tp;	<span class="comment">//只取第三个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">string</span> a;</span><br><span class="line"><span class="built_in">std</span>::make_tuple(ref(x),ref(a),ref(y)) = tp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接多个tuple元组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// printtuple.h file</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> IDX, <span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> PRINT_TUPLE&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; strm, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Args...&gt;&amp; t)</span></span>&#123;</span><br><span class="line">		strm &lt;&lt; <span class="built_in">std</span>::get&lt;IDX&gt;(t) &lt;&lt; (IDX+<span class="number">1</span>==MAX ? <span class="string">""</span> : <span class="string">","</span>);</span><br><span class="line">		PRINT_TUPLE&lt;IDX+<span class="number">1</span>,MAX,Args...&gt;::print(strm,t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化类模版，终结递归调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> PRINT_TUPLE&lt;MAX,MAX ,Args...&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; strm, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Args...&gt;&amp; t)</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (<span class="built_in">std</span>::ostream&amp; strm, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Args...&gt;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	strm &lt;&lt; <span class="string">"["</span>;</span><br><span class="line">	PRINT_TUPLE&lt;<span class="number">0</span>,<span class="keyword">sizeof</span>...(Args),Args...&gt;::print(strm,t);</span><br><span class="line">	<span class="keyword">return</span> strm &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// testtuple.cpp file</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"printtuple.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">float</span>&gt; t1(<span class="number">1</span>, <span class="string">"bb"</span>, <span class="number">1.23</span>);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> t2 = <span class="built_in">std</span>::tuple_cat(t1,<span class="built_in">std</span>::make_pair(<span class="string">"cc"</span>,<span class="string">"dd"</span>), <span class="built_in">std</span>::tie(n));</span><br><span class="line">        n = <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t2 &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/// output result</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line">[<span class="number">1</span>,bb,<span class="number">1.23</span>,cc,dd,<span class="number">20</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>从上面可以看出std::tie构造或者解构都是引用，std::make_tuple和std::ref组合使用能做到std::tie的效果。tuple无法直接输出，自己重载&lt;&lt;函数对tuple进行输出。</p>
<p>tuple虽然可以用来代替简单的结构体，但是不要滥用，否则会导致代码的可读性下降。</p>
<h3 id="小结">小结</h3><p>至此，使用C++11特性简化代码，使得代码更方便、简洁和优雅，特性有：类型推导（auto、decltype），模板别名和模板函数默认参数，基于范围的for循环，统一的初始化列表，函数包装器和函数绑定器，lambda表达式，tuple元组。</p>
<h3 id="参考资料">参考资料</h3><ol>
<li>《深入应用C++11：代码优化和工程应用》</li>
<li>《C++ Primer》（第五版）</li>
<li>《C++标准库》（第二版）</li>
</ol>

      
    </div>
    <footer class="article-footer">
		<!-- JiaThis Button BEGIN -->
		<div class="jiathis_style_32x32" style="float:right;">
			<a class="jiathis_button_qzone"></a>
			<a class="jiathis_button_tsina"></a>
			<a class="jiathis_button_tqq"></a>
			<a class="jiathis_button_weixin"></a>
			<a class="jiathis_button_renren"></a>
			<a href="http://www.jiathis.com/share?uid=2071579" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
			<a class="jiathis_counter_style"></a>
		</div>
		<script type="text/javascript">
		var jiathis_config = {data_track_clickback:'true'};
		</script>
		<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=2071579" charset="utf-8"></script>
		<!-- JiaThis Button END -->
      <!--<a data-url="http://hanhaichensha.coding.me/2016/08/09/C-11特性与应用（三）/" data-id="ciy8iuxa0003cnkvu6naxbweq" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C-11/">C++11</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/blog/2016/08/04/C-11特性与应用（二）/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">C++11特性与应用（二）</div>
    </a>
  
</nav>

  
</article>



<section id="comment">
  <h1 class="title">comment</h1>
  <div id="disqus_thread">
  <!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2071579"></script>
  <!-- UY END -->
  </div>
</section>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/C/">C++</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Linux防火墙/">Linux防火墙</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Ruby/">Ruby</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/信息编码/">信息编码</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/微信开发/">微信开发</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/杂谈/">杂谈</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/笔试/">笔试</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/计算机基础/">计算机基础</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/C-11/">C++11</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Netfilter/">Netfilter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/RSA算法/">RSA算法</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Ruby/">Ruby</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/iptables/">iptables</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/中国剩余定理/">中国剩余定理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/信息编码/">信息编码</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/关于博客/">关于博客</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/字符串/">字符串</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/并发编程/">并发编程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/微信开发/">微信开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/总结/">总结</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/扩展辗转相除法/">扩展辗转相除法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/教程/">教程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/数学/">数学</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/杂谈/">杂谈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/欧拉函数/">欧拉函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/笔试/">笔试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/笔试题/">笔试题</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/网络/">网络</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/计算机基础/">计算机基础</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/计算机网络/">计算机网络</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/费马小定理/">费马小定理</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/辗转相除法/">辗转相除法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/防火墙/">防火墙</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/C-11/" style="font-size: 17.5px;">C++11</a> <a href="/blog/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/blog/tags/Netfilter/" style="font-size: 10px;">Netfilter</a> <a href="/blog/tags/RSA算法/" style="font-size: 17.5px;">RSA算法</a> <a href="/blog/tags/Ruby/" style="font-size: 15px;">Ruby</a> <a href="/blog/tags/iptables/" style="font-size: 10px;">iptables</a> <a href="/blog/tags/中国剩余定理/" style="font-size: 10px;">中国剩余定理</a> <a href="/blog/tags/信息编码/" style="font-size: 12.5px;">信息编码</a> <a href="/blog/tags/关于博客/" style="font-size: 10px;">关于博客</a> <a href="/blog/tags/字符串/" style="font-size: 12.5px;">字符串</a> <a href="/blog/tags/并发编程/" style="font-size: 10px;">并发编程</a> <a href="/blog/tags/微信开发/" style="font-size: 10px;">微信开发</a> <a href="/blog/tags/总结/" style="font-size: 10px;">总结</a> <a href="/blog/tags/扩展辗转相除法/" style="font-size: 10px;">扩展辗转相除法</a> <a href="/blog/tags/教程/" style="font-size: 10px;">教程</a> <a href="/blog/tags/数学/" style="font-size: 20px;">数学</a> <a href="/blog/tags/杂谈/" style="font-size: 10px;">杂谈</a> <a href="/blog/tags/欧拉函数/" style="font-size: 10px;">欧拉函数</a> <a href="/blog/tags/笔试/" style="font-size: 10px;">笔试</a> <a href="/blog/tags/笔试题/" style="font-size: 12.5px;">笔试题</a> <a href="/blog/tags/网络/" style="font-size: 10px;">网络</a> <a href="/blog/tags/计算机基础/" style="font-size: 12.5px;">计算机基础</a> <a href="/blog/tags/计算机网络/" style="font-size: 12.5px;">计算机网络</a> <a href="/blog/tags/费马小定理/" style="font-size: 12.5px;">费马小定理</a> <a href="/blog/tags/辗转相除法/" style="font-size: 10px;">辗转相除法</a> <a href="/blog/tags/防火墙/" style="font-size: 10px;">防火墙</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/08/">八月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/07/">七月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/06/">六月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/03/">三月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/11/">十一月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/09/">九月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/07/">七月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/03/">三月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/02/">二月 2015</a><span class="archive-list-count">6</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2016/08/09/C-11特性与应用（三）/">C++11特性与应用（三）</a>
          </li>
        
          <li>
            <a href="/blog/2016/08/04/C-11特性与应用（二）/">C++11特性与应用（二）</a>
          </li>
        
          <li>
            <a href="/blog/2016/08/01/C-11特性与应用（一）：C-11语言特性/">C++11特性与应用（一）：C++11语言特性</a>
          </li>
        
          <li>
            <a href="/blog/2016/07/22/C-11并发编程（一）：你好，并发世界/">C++11并发编程（一）</a>
          </li>
        
          <li>
            <a href="/blog/2016/06/06/别样的进制/">别样的进制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 翰海尘沙<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">主页</a>
  
    <a href="/blog/archives/" class="mobile-nav-link">归档</a>
  
</nav>
    

<script src="/blog/js/jquery2.0.3.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/blog/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>